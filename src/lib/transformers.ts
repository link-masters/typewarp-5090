import { corruptText } from "./cursed";
import { UNICODE_MAPS } from "./fontMappings";

// Utility maps for simple substitutions
const BOLD_MAP: Record<string, string> = {
  a: "ğš",
  b: "ğ›",
  c: "ğœ",
  d: "ğ",
  e: "ğ",
  f: "ğŸ",
  g: "ğ ",
  h: "ğ¡",
  i: "ğ¢",
  j: "ğ£",
  k: "ğ¤",
  l: "ğ¥",
  m: "ğ¦",
  n: "ğ§",
  o: "ğ¨",
  p: "ğ©",
  q: "ğª",
  r: "ğ«",
  s: "ğ¬",
  t: "ğ­",
  u: "ğ®",
  v: "ğ¯",
  w: "ğ°",
  x: "ğ±",
  y: "ğ²",
  z: "ğ³",
  A: "ğ€",
  B: "ğ",
  C: "ğ‚",
  D: "ğƒ",
  E: "ğ„",
  F: "ğ…",
  G: "ğ†",
  H: "ğ‡",
  I: "ğˆ",
  J: "ğ‰",
  K: "ğŠ",
  L: "ğ‹",
  M: "ğŒ",
  N: "ğ",
  O: "ğ",
  P: "ğ",
  Q: "ğ",
  R: "ğ‘",
  S: "ğ’",
  T: "ğ“",
  U: "ğ”",
  V: "ğ•",
  W: "ğ–",
  X: "ğ—",
  Y: "ğ˜",
  Z: "ğ™",
  "0": "ğŸ",
  "1": "ğŸ",
  "2": "ğŸ",
  "3": "ğŸ‘",
  "4": "ğŸ’",
  "5": "ğŸ“",
  "6": "ğŸ”",
  "7": "ğŸ•",
  "8": "ğŸ–",
  "9": "ğŸ—",
};

const SQUARE_MAP: Record<string, string> = {
  a: "ğŸ„°",
  b: "ğŸ„±",
  c: "ğŸ„²",
  d: "ğŸ„³",
  e: "ğŸ„´",
  f: "ğŸ„µ",
  g: "ğŸ„¶",
  h: "ğŸ„·",
  i: "ğŸ„¹",
  j: "ğŸ„¹",
  k: "ğŸ„º",
  l: "ğŸ„»",
  m: "ğŸ„¼",
  n: "ğŸ„½",
  o: "ğŸ„¾",
  p: "ğŸ„¿",
  q: "ğŸ…€",
  r: "ğŸ…",
  s: "ğŸ…‚",
  t: "ğŸ…ƒ",
  u: "ğŸ…„",
  v: "ğŸ……",
  w: "ğŸ…†",
  x: "ğŸ…‡",
  y: "ğŸ…ˆ",
  z: "ğŸ…‰",
  A: "ğŸ„°",
  B: "ğŸ„±",
  C: "ğŸ„²",
  D: "ğŸ„³",
  E: "ğŸ„´",
  F: "ğŸ„µ",
  G: "ğŸ„¶",
  H: "ğŸ„·",
  I: "ğŸ„¹",
  J: "ğŸ„¹",
  K: "ğŸ„º",
  L: "ğŸ„»",
  M: "ğŸ„¼",
  N: "ğŸ„½",
  O: "ğŸ„¾",
  P: "ğŸ„¿",
  Q: "ğŸ…€",
  R: "ğŸ…",
  S: "ğŸ…‚",
  T: "ğŸ…ƒ",
  U: "ğŸ…„",
  V: "ğŸ……",
  W: "ğŸ…†",
  X: "ğŸ…‡",
  Y: "ğŸ…ˆ",
  Z: "ğŸ…‰",
};

const ITALIC_MAP: Record<string, string> = {
  a: "ğ˜¢",
  b: "ğ˜£",
  c: "ğ˜¤",
  d: "ğ˜¥",
  e: "ğ˜¦",
  f: "ğ˜§",
  g: "ğ˜¨",
  h: "ğ˜©",
  i: "ğ˜ª",
  j: "ğ˜«",
  k: "ğ˜¬",
  l: "ğ˜­",
  m: "ğ˜®",
  n: "ğ˜¯",
  o: "ğ˜°",
  p: "ğ˜±",
  q: "ğ˜²",
  r: "ğ˜³",
  s: "ğ˜´",
  t: "ğ˜µ",
  u: "ğ˜¶",
  v: "ğ˜·",
  w: "ğ˜¸",
  x: "ğ˜¹",
  y: "ğ˜º",
  z: "ğ˜»",
  A: "ğ˜ˆ",
  B: "ğ˜‰",
  C: "ğ˜Š",
  D: "ğ˜‹",
  E: "ğ˜Œ",
  F: "ğ˜",
  G: "ğ˜",
  H: "ğ˜",
  I: "ğ˜",
  J: "ğ˜‘",
  K: "ğ˜’",
  L: "ğ˜“",
  M: "ğ˜”",
  N: "ğ˜•",
  O: "ğ˜–",
  P: "ğ˜—",
  Q: "ğ˜˜",
  R: "ğ˜™",
  S: "ğ˜š",
  T: "ğ˜›",
  U: "ğ˜œ",
  V: "ğ˜",
  W: "ğ˜",
  X: "ğ˜Ÿ",
  Y: "ğ˜ ",
  Z: "ğ˜¡",
};

const MONOSPACE_MAP: Record<string, string> = {
  a: "ğšŠ",
  b: "ğš‹",
  c: "ğšŒ",
  d: "ğš",
  e: "ğš",
  f: "ğš",
  g: "ğ˜¨",
  h: "ğš‘",
  i: "ğš’",
  j: "ğš“",
  k: "ğš”",
  l: "ğš•",
  m: "ğš–",
  n: "ğš—",
  o: "ğš˜",
  p: "ğš™",
  q: "ğšš",
  r: "ğš›",
  s: "ğšœ",
  t: "ğš",
  u: "ğš",
  v: "ğšŸ",
  w: "ğš ",
  x: "ğš¡",
  y: "ğš¢",
  z: "ğš£",
  A: "ğ™°",
  B: "ğ™±",
  C: "ğ™²",
  D: "ğ™³",
  E: "ğ™´",
  F: "ğ™µ",
  G: "ğ™¶",
  H: "ğ™·",
  I: "ğ™¸",
  J: "ğ™¹",
  K: "ğ™º",
  L: "ğ™»",
  M: "ğ™¼",
  N: "ğ™½",
  O: "ğ™¾",
  P: "ğ™¿",
  Q: "ğš€",
  R: "ğš",
  S: "ğš‚",
  T: "ğšƒ",
  U: "ğš„",
  V: "ğš…",
  W: "ğš†",
  X: "ğš‡",
  Y: "ğšˆ",
  Z: "ğš‰",
  "0": "ğŸ¶",
  "1": "ğŸ·",
  "2": "ğŸ¸",
  "3": "ğŸ¹",
  "4": "ğŸº",
  "5": "ğŸ»",
  "6": "ğŸ¼",
  "7": "ğŸ½",
  "8": "ğŸ¾",
  "9": "ğŸ¿",
};

const BUBBLE_MAP: Record<string, string> = {
  a: "â“",
  b: "â“‘",
  c: "â“’",
  d: "â““",
  e: "â“”",
  f: "â“•",
  g: "â“–",
  h: "â“—",
  i: "â“˜",
  j: "â“™",
  k: "â“š",
  l: "â“›",
  m: "â“œ",
  n: "â“",
  o: "â“",
  p: "â“Ÿ",
  q: "â“ ",
  r: "â“¡",
  s: "â“¢",
  t: "â“£",
  u: "â“¤",
  v: "â“¥",
  w: "â“¦",
  x: "â“§",
  y: "â“¨",
  z: "â“©",
  A: "â’¶",
  B: "â’·",
  C: "â’¸",
  D: "â’¹",
  E: "â’º",
  F: "â’»",
  G: "â’¼",
  H: "â’½",
  I: "â’¾",
  J: "â’¿",
  K: "â“€",
  L: "â“",
  M: "â“‚",
  N: "â“ƒ",
  O: "â“„",
  P: "â“…",
  Q: "â“†",
  R: "â“‡",
  S: "â“ˆ",
  T: "â“‰",
  U: "â“Š",
  V: "â“‹",
  W: "â“Œ",
  X: "â“",
  Y: "â“",
  Z: "â“",
  "0": "â“ª",
  "1": "â‘ ",
  "2": "â‘¡",
  "3": "â‘¢",
  "4": "â‘£",
  "5": "â‘¤",
  "6": "â‘¥",
  "7": "â‘¦",
  "8": "â‘§",
  "9": "â‘¨",
};

const GOTHIC_MAP: Record<string, string> = {
  a: "ğ–†",
  b: "ğ–‡",
  c: "ğ–ˆ",
  d: "ğ–‰",
  e: "ğ–Š",
  f: "ğ–‹",
  g: "ğ–Œ",
  h: "ğ–",
  i: "ğ–",
  j: "ğ–",
  k: "ğ–",
  l: "ğ–‘",
  m: "ğ–’",
  n: "ğ–“",
  o: "ğ–”",
  p: "ğ–•",
  q: "ğ––",
  r: "ğ–—",
  s: "ğ–˜",
  t: "ğ–™",
  u: "ğ–š",
  v: "ğ–›",
  w: "ğ–œ",
  x: "ğ–",
  y: "ğ–",
  z: "ğ–Ÿ",
  A: "ğ•¬",
  B: "ğ•­",
  C: "ğ•®",
  D: "ğ•¯",
  E: "ğ•°",
  F: "ğ•±",
  G: "ğ•²",
  H: "ğ•³",
  I: "ğ•´",
  J: "ğ•µ",
  K: "ğ•¶",
  L: "ğ•·",
  M: "ğ•¸",
  N: "ğ•¹",
  O: "ğ•º",
  P: "ğ•»",
  Q: "ğ•¼",
  R: "ğ•½",
  S: "ğ•¾",
  T: "ğ•¿",
  U: "ğ–€",
  V: "ğ–",
  W: "ğ–‚",
  X: "ğ–ƒ",
  Y: "ğ–„",
  Z: "ğ–…",
};

const CURSIVE_MAP: Record<string, string> = {
  a: "ğ’¶",
  b: "ğ’·",
  c: "ğ’¸",
  d: "ğ’¹",
  e: "ğ‘’",
  f: "ğ’»",
  g: "ğ‘”",
  h: "ğ’½",
  i: "ğ’¾",
  j: "ğ’¿",
  k: "ğ“€",
  l: "ğ“",
  m: "ğ“‚",
  n: "ğ“ƒ",
  o: "ğ‘œ",
  p: "ğ“…",
  q: "ğ“†",
  r: "ğ“‡",
  s: "ğ“ˆ",
  t: "ğ“‰",
  u: "ğ“Š",
  v: "ğ“‹",
  w: "ğ“Œ",
  x: "ğ“",
  y: "ğ“",
  z: "ğ“",
  A: "ğ’œ",
  B: "ğµ",
  C: "ğ’",
  D: "ğ’Ÿ",
  E: "ğ¸",
  F: "ğ¹",
  G: "ğ’¢",
  H: "ğ»",
  I: "ğ¼",
  J: "ğ’¥",
  K: "ğ’¦",
  L: "ğ¿",
  M: "ğ‘€",
  N: "ğ’©",
  O: "ğ’ª",
  P: "ğ’«",
  Q: "ğ’¬",
  R: "ğ‘…",
  S: "ğ’®",
  T: "ğ’¯",
  U: "ğ’°",
  V: "ğ’±",
  W: "ğ’²",
  X: "ğ’³",
  Y: "ğ’´",
  Z: "ğ’µ",
};

const SUPERSCRIPT_MAP: Record<string, string> = {
  a: "áµƒ",
  b: "áµ‡",
  c: "á¶œ",
  d: "áµˆ",
  e: "áµ‰",
  f: "á¶ ",
  g: "áµ",
  h: "Ê°",
  i: "â±",
  j: "Ê²",
  k: "áµ",
  l: "Ë¡",
  m: "áµ",
  n: "â¿",
  o: "áµ’",
  p: "áµ–",
  r: "Ê³",
  s: "Ë¢",
  t: "áµ—",
  u: "áµ˜",
  v: "áµ›",
  w: "Ê·",
  x: "Ë£",
  y: "Ê¸",
  z: "á¶»",
  A: "á´¬",
  B: "á´®",
  D: "á´°",
  E: "á´±",
  G: "á´³",
  H: "á´´",
  I: "á´µ",
  J: "á´¶",
  K: "á´·",
  L: "á´¸",
  M: "á´¹",
  N: "á´º",
  O: "á´¼",
  P: "á´¾",
  R: "á´¿",
  T: "áµ€",
  U: "áµ",
  V: "â±½",
  W: "áµ‚",
  "0": "â°",
  "1": "Â¹",
  "2": "Â²",
  "3": "Â³",
  "4": "â´",
  "5": "âµ",
  "6": "â¶",
  "7": "â·",
  "8": "â¸",
  "9": "â¹",
  "+": "âº",
  "-": "â»",
  "=": "â¼",
  "(": "â½",
  ")": "â¾",
};

const MORSE_MAP: Record<string, string> = {
  A: ".-",
  B: "-...",
  C: "-.-.",
  D: "-..",
  E: ".",
  F: "..-.",
  G: "--.",
  H: "....",
  I: "..",
  J: ".---",
  K: "-.-",
  L: ".-..",
  M: "--",
  N: "-.",
  O: "---",
  P: ".--.",
  Q: "--.-",
  R: ".-.",
  S: "...",
  T: "-",
  U: "..-",
  V: "...-",
  W: ".--",
  X: "-..-",
  Y: "-.--",
  Z: "--..",
  "1": ".----",
  "2": "..---",
  "3": "...--",
  "4": "....-",
  "5": ".....",
  "6": "-....",
  "7": "--...",
  "8": "---..",
  "9": "----.",
  "0": "-----",
  ".": ".-.-.-",
  ",": "--..--",
  "?": "..--..",
  "'": ".----.",
  "!": "-.-.--",
  "/": "-..-.",
  "(": "-.--.",
  ")": "-.--.-",
  "&": ".-...",
  ":": "---...",
  ";": "-.-.-.",
  "=": "-...-",
  "+": ".-.-.",
  "-": "-....-",
  _: "..--.-",
  '"': ".-..-.",
  $: "...-..-",
  "@": ".--.-.",
  " ": "/",
};

const UPSIDE_DOWN_MAP: Record<string, string> = {
  a: "É",
  b: "q",
  c: "É”",
  d: "p",
  e: "Ç",
  f: "ÉŸ",
  g: "Æƒ",
  h: "É¥",
  i: "á´‰",
  j: "É¾",
  k: "Ê",
  l: "l",
  m: "É¯",
  n: "u",
  o: "o",
  p: "d",
  q: "b",
  r: "É¹",
  s: "s",
  t: "Ê‡",
  u: "n",
  v: "ÊŒ",
  w: "Ê",
  x: "x",
  y: "Ê",
  z: "z",
  A: "âˆ€",
  B: "ğ’",
  C: "Æ†",
  D: "á—¡",
  E: "Æ",
  F: "â„²",
  G: "â…",
  H: "H",
  I: "I",
  J: "Å¿",
  K: "â‹Š",
  L: "Ë¥",
  M: "W",
  N: "N",
  O: "O",
  P: "Ô€",
  Q: "Ã’",
  R: "á´š",
  S: "S",
  T: "âŠ¥",
  U: "âˆ©",
  V: "Î›",
  W: "M",
  X: "X",
  Y: "â…„",
  Z: "Z",
  "?": "Â¿",
  "!": "Â¡",
  ".": "Ë™",
  _: "â€¾",
};

const FLIP_TEXT_MAP: Record<string, string> = {
  a: "É’",
  b: "d",
  c: "É”",
  d: "b",
  e: "É˜",
  f: "Ê‡",
  g: "b",
  h: "Êœ",
  i: "i",
  j: "á‚±",
  k: "Ê",
  l: "l",
  m: "m",
  n: "n",
  o: "o",
  p: "q",
  q: "p",
  r: "É¿",
  s: "Æ¨",
  t: "t",
  u: "u",
  v: "v",
  w: "w",
  x: "x",
  y: "y",
  z: "Æ¹",
  A: "A",
  B: "á™ ",
  C: "Æ†",
  D: "á—¡",
  E: "Æ",
  F: "êŸ»",
  G: "Ó˜",
  H: "H",
  I: "I",
  J: "á‚±",
  K: "â‹Š",
  L: "â…ƒ",
  M: "M",
  N: "Í¶",
  O: "O",
  P: "êŸ¼",
  Q: "á»Œ",
  R: "Ğ¯",
  S: "Æ§",
  T: "T",
  U: "U",
  V: "V",
  W: "W",
  X: "X",
  Y: "Y",
  Z: "Æ§",
};

function mapChars(text: string, map: Record<string, string>): string {
  return text
    .split("")
    .map((char) => {
      if (map[char]) return map[char];
      if (char.toLowerCase() !== char && map[char.toLowerCase()])
        return map[char.toLowerCase()];
      if (char.toUpperCase() !== char && map[char.toUpperCase()])
        return map[char.toUpperCase()];
      return char;
    })
    .join("");
}

function toBinary(
  text: string,
  bitMode: string = "8",
  showPrefix: boolean = false,
): string {
  const bits = parseInt(bitMode) || 8;
  const prefix = showPrefix ? "0b" : "";
  return text
    .split("")
    .map((char) => prefix + char.charCodeAt(0).toString(2).padStart(bits, "0"))
    .join(" ");
}

function toHex(text: string): string {
  return text
    .split("")
    .map((char) =>
      char.charCodeAt(0).toString(16).toUpperCase().padStart(2, "0"),
    )
    .join(" ");
}

function toBase64(text: string): string {
  try {
    return btoa(unescape(encodeURIComponent(text)));
  } catch (e) {
    return "Error: Unsupported characters";
  }
}

function reverseText(text: string): string {
  return text.split("").reverse().join("");
}

function toBraille(text: string, showIndicator: boolean = true): string {
  const brailleMap: Record<string, string> = {
    a: "â ",
    b: "â ƒ",
    c: "â ‰",
    d: "â ™",
    e: "â ‘",
    f: "â ‹",
    g: "â ›",
    h: "â “",
    i: "â Š",
    j: "â š",
    k: "â …",
    l: "â ‡",
    m: "â ",
    n: "â ",
    o: "â •",
    p: "â ",
    q: "â Ÿ",
    r: "â —",
    s: "â ",
    t: "â ",
    u: "â ¥",
    v: "â §",
    w: "â º",
    x: "â ­",
    y: "â ½",
    z: "â µ",
    " ": "â €",
    "0": "â ´",
    "1": "â ‚",
    "2": "â †",
    "3": "â ’",
    "4": "â ²",
    "5": "â ¢",
    "6": "â –",
    "7": "â ¶",
    "8": "â ¦",
    "9": "â ”",
    ".": "â ²",
    ",": "â ‚",
    ";": "â †",
    ":": "â ’",
    "!": "â –",
    "?": "â ¦",
    "(": "â ¶",
    ")": "â ¶",
    "-": "â ¤",
  };

  return text
    .toLowerCase()
    .split("")
    .map((char) => {
      if (/[0-9]/.test(char) && showIndicator) return "â ¼" + brailleMap[char];
      return brailleMap[char] || char;
    })
    .join("");
}

const RUNIC_MAP: Record<string, string> = {
  a: "áš¨",
  b: "á›’",
  c: "áš²",
  d: "á›",
  e: "á›–",
  f: "áš ",
  g: "áš·",
  h: "áš»",
  i: "á›",
  j: "á›ƒ",
  k: "áš²",
  l: "á›š",
  m: "á›—",
  n: "áš¾",
  o: "á›Ÿ",
  p: "á›ˆ",
  q: "áš²",
  r: "áš±",
  s: "á›Š",
  t: "á›",
  u: "áš¢",
  v: "áš ",
  w: "áš¹",
  x: "áš²á›Š",
  y: "á›",
  z: "á›‰",
};

function toWingdings(text: string): string {
  const map: Record<string, string> = {
    a: "âœŒï¸",
    b: "ğŸ‘Œï¸",
    c: "ğŸ‘ï¸",
    d: "ğŸ‘ï¸",
    e: "ğŸ‘ˆï¸",
    f: "ğŸ‘‰ï¸",
    g: "ğŸ‘†ï¸",
    h: "ğŸ‘‡ï¸",
    i: "âœ‹ï¸",
    j: "â˜ºï¸",
    k: "ğŸ˜ï¸",
    l: "â˜¹ï¸",
    m: "ğŸ’£ï¸",
    n: "â˜ ï¸",
    o: "âšï¸",
    p: "âš‘ï¸",
    q: "âœ‰ï¸",
    r: "âœ‚ï¸",
    s: "âœï¸",
    t: "ğŸ‘“ï¸",
    u: "âŒ›ï¸",
    v: "âŒ¨ï¸",
    w: "ğŸ–±ï¸",
    x: "ğŸ–¨ï¸",
    y: "ğŸ“ï¸",
    z: "ğŸ“‚ï¸",
    A: "âœŒï¸",
    B: "ğŸ‘Œï¸",
    C: "ğŸ‘ï¸",
    D: "ğŸ‘ï¸",
    E: "ğŸ‘ˆï¸",
    F: "ğŸ‘‰ï¸",
    G: "ğŸ‘†ï¸",
    H: "ğŸ‘‡ï¸",
    I: "âœ‹ï¸",
    J: "â˜ºï¸",
    K: "ğŸ˜ï¸",
    L: "â˜¹ï¸",
    M: "ğŸ’£ï¸",
    N: "â˜ ï¸",
    O: "âšï¸",
    P: "âš‘ï¸",
    Q: "âœ‰ï¸",
    R: "âœ‚ï¸",
    S: "âœï¸",
    T: "ğŸ‘“ï¸",
    U: "âŒ›ï¸",
    V: "âŒ¨ï¸",
    W: "ğŸ–±ï¸",
    X: "ğŸ–¨ï¸",
    Y: "ğŸ“ï¸",
    Z: "ğŸ“‚ï¸",
    "0": "ğŸ“ï¸",
    "1": "ğŸ“‚ï¸",
    "2": "ğŸ“„ï¸",
    "3": "ğŸ“…ï¸",
    "4": "ğŸ“¦ï¸",
    "5": "ğŸ“«ï¸",
    "6": "ğŸ“¬ï¸",
    "7": "ğŸ“ªï¸",
    "8": "ğŸ“ªï¸",
    "9": "ğŸ“ªï¸",
  };
  return mapChars(text, map);
}

function toSignLanguage(text: string): string {
  const map: Record<string, string> = {
    a: "ğŸ‘Œ",
    b: "âœ‹",
    c: "ğŸ¤",
    d: "â˜ï¸",
    e: "âœŠ",
    f: "ğŸ‘Œ",
    g: "ğŸ«µ",
    h: "ğŸ¤˜",
    i: "â˜ï¸",
    j: "â¤´ï¸",
    k: "ğŸ––",
    l: "ğŸ¤™",
    m: "âœ‹",
    n: "âœ‹",
    o: "ğŸ‘Œ",
    p: "ğŸ¤",
    q: "ğŸ«µ",
    r: "ğŸ¤",
    s: "âœŠ",
    t: "âœŠ",
    u: "âœŒï¸",
    v: "âœŒï¸",
    w: "ğŸ¤Ÿ",
    x: "â˜ï¸",
    y: "ğŸ¤™",
    z: "ğŸ‘‰",
    " ": "  ",
  };
  return mapChars(text.toLowerCase(), map);
}

function generateAsciiArt(text: string, font: string = "std"): string {
  const upperText = text.toUpperCase();

  const fonts: Record<
    string,
    { height: number; chars: Record<string, string[]> }
  > = {
    banner: {
      height: 5,
      chars: {
        A: ["  #  ", " # # ", "#####", "#   #", "#   #"],
        B: ["#### ", "#   #", "#### ", "#   #", "#### "],
        C: [" ####", "#    ", "#    ", "#    ", " ####"],
        D: ["#### ", "#   #", "#   #", "#   #", "#### "],
        E: ["#####", "#    ", "#### ", "#    ", "#####"],
        F: ["#####", "#    ", "#### ", "#    ", "#    "],
        G: [" ####", "#    ", "# ###", "#   #", " ### "],
        H: ["#   #", "#   #", "#####", "#   #", "#   #"],
        I: ["#####", "  #  ", "  #  ", "  #  ", "#####"],
        J: ["  ###", "    #", "    #", "#   #", " ### "],
        K: ["#   #", "#  # ", "###  ", "#  # ", "#   #"],
        L: ["#    ", "#    ", "#    ", "#    ", "#####"],
        M: ["#   #", "## ##", "# # #", "#   #", "#   #"],
        N: ["#   #", "##  #", "# # #", "#  ##", "#   #"],
        O: [" ### ", "#   #", "#   #", "#   #", " ### "],
        P: ["#### ", "#   #", "#### ", "#    ", "#    "],
        Q: [" ### ", "#   #", "# # #", "#  ##", " ####"],
        R: ["#### ", "#   #", "#### ", "#  # ", "#   #"],
        S: [" ####", "#    ", " ### ", "    #", "#### "],
        T: ["#####", "  #  ", "  #  ", "  #  ", "  #  "],
        U: ["#   #", "#   #", "#   #", "#   #", " ### "],
        V: ["#   #", "#   #", " # # ", " # # ", "  #  "],
        W: ["#   #", "#   #", "# # #", "## ##", "#   #"],
        X: ["#   #", " # # ", "  #  ", " # # ", "#   #"],
        Y: ["#   #", " # # ", "  #  ", "  #  ", "  #  "],
        Z: ["#####", "   # ", "  #  ", " #   ", "#####"],
        " ": ["     ", "     ", "     ", "     ", "     "],
      },
    },
    big: {
      height: 5,
      chars: {
        A: ["  AA  ", " A  A ", "AAAAAA", "A    A", "A    A"],
        B: ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
        C: [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
        D: ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
        E: ["EEEEE", "E    ", "EEEE ", "E    ", "EEEEE"],
        F: ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
        G: [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
        H: ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
        I: ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
        J: ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
        K: ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
        L: ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
        M: ["M   M", "MM MM", "M M M", "M   M", "M   M"],
        N: ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
        O: [" OOO ", "O   O", "O   O", "O   O", " OOO "],
        P: ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
        Q: [" QQQ ", "Q   Q", "Q Q Q", "Q  QQ", " QQQQ"],
        R: ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
        S: [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
        T: ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
        U: ["U   U", "U   U", "U   U", "U   U", " UUU "],
        V: ["V   V", "V   V", " V V ", " V V ", "  V  "],
        W: ["W   W", "W   W", "W W W", "WW WW", "W   W"],
        X: ["X   X", " X X ", "  X  ", " X X ", "X   X"],
        Y: ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
        Z: ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"],
        " ": ["      ", "      ", "      ", "      ", "      "],
      },
    },
    block: {
      height: 3,
      chars: {
        A: ["â–ˆâ–€â–€â–ˆ", "â–ˆâ–„â–„â–ˆ", "â–ˆ  â–ˆ"],
        B: ["â–ˆâ–€â–€â–„", "â–ˆâ–€â–€â–„", "â–ˆâ–„â–„â–€"],
        C: ["â–ˆâ–€â–€â–€", "â–ˆ   ", "â–ˆâ–„â–„â–„"],
        D: ["â–ˆâ–€â–€â–„", "â–ˆ  â–ˆ", "â–ˆâ–„â–„â–€"],
        E: ["â–ˆâ–€â–€â–€", "â–ˆâ–€â–€ ", "â–ˆâ–„â–„â–„"],
        F: ["â–ˆâ–€â–€â–€", "â–ˆâ–€â–€ ", "â–ˆ   "],
        G: ["â–ˆâ–€â–€â–€", "â–ˆ â–€â–ˆ", "â–ˆâ–„â–„â–ˆ"],
        H: ["â–ˆ  â–ˆ", "â–ˆâ–€â–€â–ˆ", "â–ˆ  â–ˆ"],
        I: ["â–€â–ˆâ–€", " â–ˆ ", "â–„â–ˆâ–„"],
        J: ["  â–ˆ", "  â–ˆ", "â–ˆâ–„â–ˆ"],
        K: ["â–ˆ â–ˆ", "â–ˆâ–€â–„", "â–ˆ â–ˆ"],
        L: ["â–ˆ  ", "â–ˆ  ", "â–ˆâ–„â–„"],
        M: ["â–ˆâ–„ â–„â–ˆ", "â–ˆ â–ˆ â–ˆ", "â–ˆ   â–ˆ"],
        N: ["â–ˆâ–„  â–ˆ", "â–ˆ â–ˆ â–ˆ", "â–ˆ  â–€â–ˆ"],
        O: ["â–ˆâ–€â–€â–ˆ", "â–ˆ  â–ˆ", "â–ˆâ–„â–„â–ˆ"],
        P: ["â–ˆâ–€â–€â–ˆ", "â–ˆâ–€â–€â–€", "â–ˆ   "],
        Q: ["â–ˆâ–€â–€â–ˆ", "â–ˆ â–„â–ˆ", "â–ˆâ–„â–„â–€"],
        R: ["â–ˆâ–€â–€â–ˆ", "â–ˆâ–€â–€â–„", "â–ˆ  â–ˆ"],
        S: ["â–ˆâ–€â–€â–€", " â–€â–€â–ˆ", "â–„â–„â–„â–ˆ"],
        T: ["â–€â–€â–ˆâ–€â–€", "  â–ˆ  ", "  â–ˆ  "],
        U: ["â–ˆ  â–ˆ", "â–ˆ  â–ˆ", "â–ˆâ–„â–„â–ˆ"],
        V: ["â–ˆ  â–ˆ", "â–ˆ  â–ˆ", " â–€â–€ "],
        W: ["â–ˆ   â–ˆ", "â–ˆ â–ˆ â–ˆ", "â–ˆâ–„ â–„â–ˆ"],
        X: ["â–€â–„ â–„â–€", " â–„â–ˆâ–„ ", "â–€â–€ â–€â–€"],
        Y: ["â–ˆ  â–ˆ", " â–€â–€ ", " â–€â–€ "],
        Z: ["â–€â–€â–€â–ˆ", " â–„â–€ ", "â–ˆâ–„â–„â–„"],
        " ": ["   ", "   ", "   "],
      },
    },
    mini: {
      height: 2,
      chars: {
        A: ["â–²", "â–ˆ"],
        B: ["â–€â–„", "â–„â–€"],
        C: ["â–„", "â–€"],
        D: ["â–€â–„", "â–„â–€"],
        E: ["â–€", "â–„"],
        F: ["â–€", "â–ˆ"],
        G: ["â–„â–„", "â–€â–ˆ"],
        H: ["â–ˆâ–€â–ˆ", "â–ˆ â–ˆ"],
        I: ["â–€â–ˆâ–€", " â–ˆ "],
        J: [" â–ˆ", "â–€â–€"],
        K: ["â–ˆâ–€", "â–ˆâ–„"],
        L: ["â–ˆ ", "â–€â–€"],
        M: ["â–ˆâ–€â–ˆ", "â–ˆ â–ˆ"],
        N: ["â–ˆâ–„â–ˆ", "â–ˆ â–ˆ"],
        O: ["â–ˆâ–€â–ˆ", "â–€â–€â–€"],
        P: ["â–ˆâ–€", "â–ˆ "],
        Q: ["â–ˆâ–€â–ˆ", " â–€â–„"],
        R: ["â–ˆâ–€", "â–ˆâ–„"],
        S: ["â–€â–„", "â–„â–€"],
        T: ["â–€â–ˆâ–€", " â–ˆ "],
        U: ["â–ˆ â–ˆ", "â–€â–€â–€"],
        V: ["â–ˆ â–ˆ", " â–€ "],
        W: ["â–ˆ â–ˆ", "â–ˆâ–€â–ˆ"],
        X: ["â–€â–„â–€", "â–„â–€â–„"],
        Y: ["â–ˆ â–ˆ", " â–€ "],
        Z: ["â–€â–€â–ˆ", "â–ˆâ–€â–€"],
        " ": [" ", " "],
      },
    },
    shadow: {
      height: 4,
      chars: {
        A: ["  â–„â–ˆâ–‘  ", " â–ˆâ–€â–ˆâ–‘  ", "â–ˆâ–€â–€â–€â–ˆâ–‘ ", "â–ˆ   â–ˆâ–‘ "],
        B: ["â–ˆâ–€â–€â–€â–ˆâ–‘", "â–ˆâ–€â–€â–€â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", "â–ˆâ–„â–„â–„â–ˆâ–‘"],
        C: [" â–„â–„â–„â–‘ ", "â–ˆâ–‘â–‘â–‘  ", "â–ˆâ–‘â–‘â–‘  ", " â–€â–€â–€â–‘ "],
        D: ["â–ˆâ–€â–€â–€â–„â–‘", "â–ˆ   â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", "â–ˆâ–„â–„â–„â–€â–‘"],
        E: ["â–ˆâ–€â–€â–€â–€â–‘", "â–ˆâ–€â–€â–€â–‘ ", "â–ˆâ–‘â–‘â–‘â–‘ ", "â–ˆâ–„â–„â–„â–„â–‘"],
        F: ["â–ˆâ–€â–€â–€â–€â–‘", "â–ˆâ–€â–€â–€â–‘ ", "â–ˆâ–‘â–‘â–‘â–‘ ", "â–ˆâ–‘â–‘â–‘â–‘ "],
        G: [" â–„â–„â–„â–‘ ", "â–ˆâ–‘â–‘â–‘  ", "â–ˆ  â–€â–ˆâ–‘", " â–€â–€â–€â–‘ "],
        H: ["â–ˆâ–‘  â–ˆâ–‘", "â–ˆâ–€â–€â–€â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", "â–ˆ   â–ˆâ–‘"],
        I: ["â–ˆâ–ˆâ–ˆâ–‘", " â–ˆâ–‘ ", " â–ˆâ–‘ ", "â–ˆâ–ˆâ–ˆâ–‘"],
        J: ["  â–„â–ˆâ–‘", "   â–ˆâ–‘", "â–ˆ  â–ˆâ–‘", " â–€â–€â–‘ "],
        K: ["â–ˆâ–‘ â–ˆâ–‘", "â–ˆâ–€â–€â–‘ ", "â–ˆâ–€â–€â–‘ ", "â–ˆâ–‘ â–ˆâ–‘"],
        L: ["â–ˆâ–‘   ", "â–ˆâ–‘   ", "â–ˆâ–‘   ", "â–ˆâ–€â–€â–€â–‘"],
        M: ["â–ˆâ–„â–‘â–„â–ˆâ–‘", "â–ˆ â–ˆ â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", "â–ˆ   â–ˆâ–‘"],
        N: ["â–ˆâ–„  â–ˆâ–‘", "â–ˆ â–ˆ â–ˆâ–‘", "â–ˆ  â–€â–ˆâ–‘", "â–ˆ   â–ˆâ–‘"],
        O: [" â–„â–„â–„â–‘ ", "â–ˆ   â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", " â–€â–€â–€â–‘ "],
        P: ["â–ˆâ–€â–€â–€â–ˆâ–‘", "â–ˆâ–€â–€â–€â–‘ ", "â–ˆâ–‘â–‘â–‘â–‘ ", "â–ˆâ–‘â–‘â–‘â–‘ "],
        Q: [" â–„â–„â–„â–‘ ", "â–ˆ   â–ˆâ–‘", "â–ˆ  â–„â–ˆâ–‘", " â–€â–€â–€â–„â–‘"],
        R: ["â–ˆâ–€â–€â–€â–ˆâ–‘", "â–ˆâ–€â–€â–ˆâ–‘ ", "â–ˆâ–‘ â–ˆâ–‘ ", "â–ˆâ–‘  â–ˆâ–‘"],
        S: [" â–„â–„â–„â–‘", "â–€â–„â–‘â–‘â–‘", "â–‘â–‘â–€â–„â–‘", "â–„â–„â–„â–€â–‘"],
        T: ["â–ˆâ–€â–€â–€â–ˆâ–‘", "  â–ˆâ–‘  ", "  â–ˆâ–‘  ", "  â–ˆâ–‘  "],
        U: ["â–ˆâ–‘  â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", " â–€â–€â–€â–‘ "],
        V: ["â–ˆâ–‘  â–ˆâ–‘", "â–ˆ   â–ˆâ–‘", " â–ˆ â–ˆâ–‘ ", "  â–€â–‘  "],
        W: ["â–ˆâ–‘  â–ˆâ–‘", "â–ˆ â–„ â–ˆâ–‘", "â–ˆâ–€ â–€â–ˆâ–‘", "â–ˆ   â–ˆâ–‘"],
        X: ["â–ˆâ–‘  â–ˆâ–‘", " â–€â–„â–€â–‘ ", " â–„â–€â–„â–‘ ", "â–ˆâ–‘  â–ˆâ–‘"],
        Y: ["â–ˆâ–‘  â–ˆâ–‘", " â–€â–„â–€â–‘ ", "  â–ˆâ–‘  ", "  â–ˆâ–‘  "],
        Z: ["â–ˆâ–€â–€â–€â–ˆâ–‘", "  â–„â–€â–‘ ", " â–„â–€â–‘â–‘ ", "â–ˆâ–„â–„â–„â–ˆâ–‘"],
        " ": ["      ", "      ", "      ", "      "],
      },
    },
    isometric: {
      height: 4,
      chars: {
        A: ["  â–„â–ˆâ–„  ", " â–ˆâ–€ â–€â–ˆ ", "â–ˆâ–„â–„â–„â–„â–„â–ˆ", "â–ˆ     â–ˆ"],
        B: ["â–ˆâ–€â–€â–€â–€â–„", "â–ˆâ–„â–„â–„â–„â–€", "â–ˆ    â–ˆ", "â–ˆâ–„â–„â–„â–„â–€"],
        C: [" â–„â–€â–€â–€â–€", "â–ˆ     ", "â–ˆ     ", " â–€â–„â–„â–„â–„"],
        D: ["â–ˆâ–€â–€â–€â–€â–„", "â–ˆ    â–ˆ", "â–ˆ    â–ˆ", "â–ˆâ–„â–„â–„â–„â–€"],
        E: ["â–ˆâ–€â–€â–€â–€â–€", "â–ˆâ–„â–„â–„  ", "â–ˆ     ", "â–ˆâ–„â–„â–„â–„â–„"],
        F: ["â–ˆâ–€â–€â–€â–€â–€", "â–ˆâ–„â–„â–„  ", "â–ˆ     ", "â–ˆ     "],
        G: [" â–„â–€â–€â–€â–€", "â–ˆ     ", "â–ˆ  â–€â–€â–ˆ", " â–€â–„â–„â–„â–€"],
        H: ["â–ˆ    â–ˆ", "â–ˆâ–„â–„â–„â–„â–ˆ", "â–ˆ    â–ˆ", "â–ˆ    â–ˆ"],
        I: ["â–€â–€â–ˆâ–€â–€", "  â–ˆ  ", "  â–ˆ  ", "â–„â–„â–ˆâ–„â–„"],
        J: ["   â–€â–ˆ", "    â–ˆ", "â–„   â–ˆ", " â–€â–€â–€ "],
        K: ["â–ˆ   â–„â–€", "â–ˆ â–„â–€  ", "â–ˆâ–€â–„   ", "â–ˆ  â–€â–„ "],
        L: ["â–ˆ     ", "â–ˆ     ", "â–ˆ     ", "â–ˆâ–„â–„â–„â–„â–„"],
        M: ["â–ˆâ–„   â–„â–ˆ", "â–ˆ â–€â–„â–€ â–ˆ", "â–ˆ     â–ˆ", "â–ˆ     â–ˆ"],
        N: ["â–ˆâ–„    â–ˆ", "â–ˆ â–€â–„  â–ˆ", "â–ˆ   â–€â–„â–ˆ", "â–ˆ     â–ˆ"],
        O: [" â–„â–€â–€â–€â–„ ", "â–ˆ     â–ˆ", "â–ˆ     â–ˆ", " â–€â–„â–„â–„â–€ "],
        P: ["â–ˆâ–€â–€â–€â–€â–„", "â–ˆ    â–ˆ", "â–ˆâ–„â–„â–„â–„â–€", "â–ˆ     "],
        Q: [" â–„â–€â–€â–€â–„ ", "â–ˆ     â–ˆ", "â–ˆ   â–„ â–ˆ", " â–€â–„â–„â–€â–„â–€"],
        R: ["â–ˆâ–€â–€â–€â–€â–„", "â–ˆ    â–ˆ", "â–ˆâ–„â–„â–„â–„â–€", "â–ˆ   â–€â–„"],
        S: [" â–„â–€â–€â–€â–€", "â–€â–„    ", "   â–€â–„ ", "â–„â–„â–„â–„â–€ "],
        T: ["â–€â–€â–ˆâ–€â–€â–€", "  â–ˆ   ", "  â–ˆ   ", "  â–ˆ   "],
        U: ["â–ˆ    â–ˆ", "â–ˆ    â–ˆ", "â–ˆ    â–ˆ", " â–€â–„â–„â–„â–€"],
        V: ["â–ˆ    â–ˆ", "â–ˆ    â–ˆ", " â–€â–„â–„â–€ ", "  â–€â–€  "],
        W: ["â–ˆ     â–ˆ", "â–ˆ  â–„  â–ˆ", "â–ˆ â–€ â–€ â–ˆ", "â–ˆâ–€   â–€â–ˆ"],
        X: ["â–€â–„   â–„â–€", "  â–€â–„â–€  ", "  â–„â–€â–„  ", "â–„â–€   â–€â–„"],
        Y: ["â–€â–„   â–„â–€", "  â–€â–„â–€  ", "   â–ˆ   ", "   â–ˆ   "],
        Z: ["â–€â–€â–€â–€â–€â–ˆ", "   â–„â–€ ", "  â–„â–€  ", "â–ˆâ–„â–„â–„â–„â–„"],
        " ": ["      ", "      ", "      ", "      "],
      },
    },
    graffiti: {
      height: 3,
      chars: {
        A: ["â–„â–€â–ˆ", "â–ˆâ–€â–ˆ", "â–€ â–€"],
        B: ["â–ˆâ–„â–„", "â–ˆâ–„â–ˆ", "â–€â–€â–€"],
        C: ["â–ˆâ–€â–€", "â–ˆâ–„â–„", "â–€â–€â–€"],
        D: ["â–ˆâ–€â–„", "â–ˆâ–„â–€", "â–€â–€â–€"],
        E: ["â–ˆâ–€â–€", "â–ˆâ–€â–€", "â–€â–€â–€"],
        F: ["â–ˆâ–€â–€", "â–ˆâ–€â–€", "â–€  "],
        G: ["â–ˆâ–€â–ˆ", "â–ˆâ–„â–ˆ", "â–€â–€â–€"],
        H: ["â–ˆ â–ˆ", "â–ˆâ–€â–ˆ", "â–€ â–€"],
        I: ["â–ˆ", "â–ˆ", "â–€"],
        J: ["  â–ˆ", "â–ˆâ–„â–ˆ", "â–€â–€â–€"],
        K: ["â–ˆâ–„â–€", "â–ˆ â–ˆ", "â–€ â–€"],
        L: ["â–ˆ  ", "â–ˆâ–„â–„", "â–€â–€â–€"],
        M: ["â–ˆâ–€â–„â–€â–ˆ", "â–ˆ â–€ â–ˆ", "â–€   â–€"],
        N: ["â–ˆâ–„ â–ˆ", "â–ˆ â–€â–ˆ", "â–€  â–€"],
        O: ["â–ˆâ–€â–ˆ", "â–ˆâ–„â–ˆ", "â–€â–€â–€"],
        P: ["â–ˆâ–€â–ˆ", "â–ˆâ–€â–€", "â–€  "],
        Q: ["â–ˆâ–€â–ˆ", "â–ˆâ–€â–ˆ", "â–€â–€â–ˆ"],
        R: ["â–ˆâ–€â–ˆ", "â–ˆâ–€â–„", "â–€ â–€"],
        S: ["â–„â–€â–ˆ", "â–„â–€â–ˆ", "â–€â–€â–€"],
        T: ["â–€â–ˆâ–€", " â–ˆ ", " â–€ "],
        U: ["â–ˆ â–ˆ", "â–ˆâ–„â–ˆ", "â–€â–€â–€"],
        V: ["â–ˆ â–ˆ", "â–€â–„â–€", " â–€ "],
        W: ["â–ˆ â–ˆ â–ˆ", "â–ˆâ–„â–€â–„â–ˆ", "â–€ â–€ â–€"],
        X: ["â–€â–„â–€", "â–ˆ â–ˆ", "â–€ â–€"],
        Y: ["â–ˆ â–ˆ", "â–€â–€â–ˆ", "â–€â–€â–€"],
        Z: ["â–€â–€â–ˆ", "â–„â–€ ", "â–€â–€â–€"],
        " ": ["   ", "   ", "   "],
      },
    },
    bubble: {
      height: 1,
      chars: {
        A: ["â’¶"],
        B: ["â’·"],
        C: ["â’¸"],
        D: ["â’¹"],
        E: ["â’º"],
        F: ["â’»"],
        G: ["â’¼"],
        H: ["â’½"],
        I: ["â’¾"],
        J: ["â’¿"],
        K: ["â“€"],
        L: ["â“"],
        M: ["â“‚"],
        N: ["â“ƒ"],
        O: ["â“„"],
        P: ["â“…"],
        Q: ["â“†"],
        R: ["â“‡"],
        S: ["â“ˆ"],
        T: ["â“‰"],
        U: ["â“Š"],
        V: ["â“‹"],
        W: ["â“Œ"],
        X: ["â“"],
        Y: ["â“"],
        Z: ["â“"],
        " ": [" "],
      },
    },
    digital: {
      height: 3,
      chars: {
        A: [" â–ˆ ", "â–ˆâ–€â–ˆ", "â–ˆ â–ˆ"],
        B: ["â–ˆâ–€â–„", "â–ˆâ–€â–„", "â–ˆâ–„â–€"],
        C: ["â–ˆâ–€â–€", "â–ˆ  ", "â–ˆâ–„â–„"],
        D: ["â–ˆâ–€â–„", "â–ˆ â–ˆ", "â–ˆâ–„â–€"],
        E: ["â–ˆâ–€â–€", "â–ˆâ–€â–€", "â–ˆâ–„â–„"],
        F: ["â–ˆâ–€â–€", "â–ˆâ–€â–€", "â–ˆ  "],
        G: ["â–ˆâ–€â–€", "â–ˆ â–ˆ", "â–ˆâ–„â–ˆ"],
        H: ["â–ˆ â–ˆ", "â–ˆâ–€â–ˆ", "â–ˆ â–ˆ"],
        I: ["â–ˆ", "â–ˆ", "â–ˆ"],
        J: ["  â–ˆ", "  â–ˆ", "â–ˆâ–„â–ˆ"],
        K: ["â–ˆ â–ˆ", "â–ˆâ–€â–„", "â–ˆ â–ˆ"],
        L: ["â–ˆ  ", "â–ˆ  ", "â–ˆâ–„â–„"],
        M: ["â–ˆâ–„â–ˆ", "â–ˆ â–ˆ", "â–ˆ â–ˆ"],
        N: ["â–ˆâ–„ â–ˆ", "â–ˆ â–€â–ˆ", "â–ˆ  â–ˆ"],
        O: ["â–ˆâ–€â–ˆ", "â–ˆ â–ˆ", "â–ˆâ–„â–ˆ"],
        P: ["â–ˆâ–€â–ˆ", "â–ˆâ–€â–€", "â–ˆ  "],
        Q: ["â–ˆâ–€â–ˆ", "â–ˆ â–ˆ", "â–€â–€â–ˆ"],
        R: ["â–ˆâ–€â–ˆ", "â–ˆâ–€â–„", "â–ˆ â–ˆ"],
        S: ["â–ˆâ–€â–€", "â–€â–€â–ˆ", "â–„â–„â–ˆ"],
        T: ["â–€â–ˆâ–€", " â–ˆ ", " â–ˆ "],
        U: ["â–ˆ â–ˆ", "â–ˆ â–ˆ", "â–ˆâ–„â–ˆ"],
        V: ["â–ˆ â–ˆ", "â–ˆ â–ˆ", " â–€ "],
        W: ["â–ˆ â–ˆ", "â–ˆâ–„â–ˆ", "â–ˆ â–ˆ"],
        X: ["â–ˆ â–ˆ", " â–ˆ ", "â–ˆ â–ˆ"],
        Y: ["â–ˆ â–ˆ", "â–€â–€â–ˆ", " â–€ "],
        Z: ["â–€â–€â–ˆ", " â–ˆ ", "â–ˆâ–„â–„"],
        " ": ["   ", "   ", "   "],
      },
    },
    std: {
      height: 6,
      chars: {
        A: [
          " â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
          "â•šâ•â•  â•šâ•â•",
        ],
        B: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          "â•šâ•â•â•â•â•â• ",
        ],
        C: [
          " â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•”â•â•â•â•â•",
          "â–ˆâ–ˆâ•‘     ",
          "â–ˆâ–ˆâ•‘     ",
          "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          " â•šâ•â•â•â•â•â•",
        ],
        D: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          "â•šâ•â•â•â•â•â• ",
        ],
        E: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•”â•â•â•â•â•",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  ",
          "â–ˆâ–ˆâ•”â•â•â•  ",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â•šâ•â•â•â•â•â•â•",
        ],
        F: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•”â•â•â•â•â•",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  ",
          "â–ˆâ–ˆâ•”â•â•â•  ",
          "â–ˆâ–ˆâ•‘     ",
          "â•šâ•â•     ",
        ],
        G: [
          " â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â•â•â• ",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          " â•šâ•â•â•â•â•â• ",
        ],
        H: [
          "â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
          "â•šâ•â•  â•šâ•â•",
        ],
        I: ["â–ˆâ–ˆâ•—", "â–ˆâ–ˆâ•‘", "â–ˆâ–ˆâ•‘", "â–ˆâ–ˆâ•‘", "â–ˆâ–ˆâ•‘", "â•šâ•â•"],
        J: [
          "     â–ˆâ–ˆâ•—",
          "     â–ˆâ–ˆâ•‘",
          "     â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆ   â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          " â•šâ•â•â•â•â• ",
        ],
        K: [
          "â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• ",
          "â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—",
          "â•šâ•â•  â•šâ•â•",
        ],
        L: [
          "â–ˆâ–ˆâ•—     ",
          "â–ˆâ–ˆâ•‘     ",
          "â–ˆâ–ˆâ•‘     ",
          "â–ˆâ–ˆâ•‘     ",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â•šâ•â•â•â•â•â•â•",
        ],
        M: [
          "â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘",
          "â•šâ•â•     â•šâ•â•",
        ],
        N: [
          "â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘",
          "â•šâ•â•  â•šâ•â•â•â•",
        ],
        O: [
          " â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          " â•šâ•â•â•â•â•â• ",
        ],
        P: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          "â–ˆâ–ˆâ•”â•â•â•â• ",
          "â–ˆâ–ˆâ•‘     ",
          "â•šâ•â•     ",
        ],
        Q: [
          " â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘â–„â–„ â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          " â•šâ•â•â–€â–€â•â• ",
        ],
        R: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          "â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘",
          "â•šâ•â•  â•šâ•â•",
        ],
        S: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•”â•â•â•â•â•",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â•šâ•â•â•â•â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘",
          "â•šâ•â•â•â•â•â•â•",
        ],
        T: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â•šâ•â•â–ˆâ–ˆâ•”â•â•â•",
          "   â–ˆâ–ˆâ•‘   ",
          "   â–ˆâ–ˆâ•‘   ",
          "   â–ˆâ–ˆâ•‘   ",
          "   â•šâ•â•   ",
        ],
        U: [
          "â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•",
          " â•šâ•â•â•â•â•â• ",
        ],
        V: [
          "â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•",
          " â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• ",
          "  â•šâ•â•â•â•  ",
        ],
        W: [
          "â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—",
          "â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘",
          "â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘",
          "â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•",
          " â•šâ•â•â•â•šâ•â•â• ",
        ],
        X: [
          "â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—",
          "â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•",
          " â•šâ–ˆâ–ˆâ–ˆâ•”â• ",
          " â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— ",
          "â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—",
          "â•šâ•â•  â•šâ•â•",
        ],
        Y: [
          "â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—",
          "â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•",
          " â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• ",
          "  â•šâ–ˆâ–ˆâ•”â•  ",
          "   â–ˆâ–ˆâ•‘   ",
          "   â•šâ•â•   ",
        ],
        Z: [
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•",
          "  â–ˆâ–ˆâ–ˆâ•”â• ",
          " â–ˆâ–ˆâ–ˆâ•”â•  ",
          "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
          "â•šâ•â•â•â•â•â•â•",
        ],
        " ": ["    ", "    ", "    ", "    ", "    ", "    "],
      },
    },
  };

  const selectedFont = fonts[font] || fonts.std;
  const lines: string[] = Array(selectedFont.height).fill("");

  for (const char of upperText) {
    const art = selectedFont.chars[char] || selectedFont.chars[" "];
    for (let i = 0; i < selectedFont.height; i++) {
      lines[i] += (art[i] || " ".repeat(art[0]?.length || 4)) + " ";
    }
  }

  return lines.join("\n");
}

// Main transformation logic
export interface TransformOptions {
  intensity?: number;
  spacing?: number;
  uppercase?: boolean;
  style?: string;
  decoration?: string;
  customSettings?: Record<string, any>;
}

const SUBSCRIPT_MAP: Record<string, string> = {
  "0": "â‚€",
  "1": "â‚",
  "2": "â‚‚",
  "3": "â‚ƒ",
  "4": "â‚„",
  "5": "â‚…",
  "6": "â‚†",
  "7": "â‚‡",
  "8": "â‚ˆ",
  "9": "â‚‰",
  a: "â‚",
  e: "â‚‘",
  h: "â‚•",
  i: "áµ¢",
  j: "â±¼",
  k: "â‚–",
  l: "â‚—",
  m: "â‚˜",
  n: "â‚™",
  o: "â‚’",
  p: "â‚š",
  r: "áµ£",
  s: "â‚›",
  t: "â‚œ",
  u: "áµ¤",
  v: "áµ¥",
  x: "â‚“",
};

// Helper to apply advanced styles
function applyFontStyle(text: string, style: string): string {
  // Check imported maps first
  if (UNICODE_MAPS[style]) {
    return mapChars(text, UNICODE_MAPS[style]);
  }

  // Fallback / Custom Logic
  switch (style) {
    case "mathBold":
      return mapChars(text, BOLD_MAP);
    case "mathItalic":
      return mapChars(text, ITALIC_MAP);
    case "mathBoldItalic":
      return text
        .split("")
        .map((c) => {
          if (c >= "a" && c <= "z")
            return String.fromCodePoint(0x1d482 + c.charCodeAt(0) - 97);
          if (c >= "A" && c <= "Z")
            return String.fromCodePoint(0x1d468 + c.charCodeAt(0) - 65);
          return c;
        })
        .join("");
    case "serifItalic":
      return text
        .split("")
        .map((c) => {
          if (c >= "a" && c <= "z")
            return String.fromCodePoint(0x1d44e + c.charCodeAt(0) - 97);
          if (c >= "A" && c <= "Z")
            return String.fromCodePoint(0x1d434 + c.charCodeAt(0) - 65);
          return c;
        })
        .join("");
    case "smallCaps":
      return mapChars(text.toLowerCase(), UNICODE_MAPS.smallCaps || {});
    case "upsideDown":
      return mapChars(text, UPSIDE_DOWN_MAP).split("").reverse().join("");
    case "mirror":
      return mapChars(text, FLIP_TEXT_MAP).split("").reverse().join("");
    case "zalgo":
    case "glitch":
      return corruptText(text, 10);
    case "subscript":
      return mapChars(text, SUBSCRIPT_MAP);
    case "superscript":
      return mapChars(text, SUPERSCRIPT_MAP);
    case "bubble":
      return mapChars(text, BUBBLE_MAP);
    case "strikethrough":
      return text
        .split("")
        .map((c) => c + "\u0336")
        .join("");
    case "underline":
      return text
        .split("")
        .map((c) => c + "\u0332")
        .join("");
    case "doubleUnderline":
      return text
        .split("")
        .map((c) => c + "\u0333")
        .join("");
    case "overline":
      return text
        .split("")
        .map((c) => c + "\u0305")
        .join("");
    case "shortStrike":
    case "shortSlash":
      return text
        .split("")
        .map((c) => c + "\u0337")
        .join("");
    case "tildeStrike":
      return text
        .split("")
        .map((c) => c + "\u0334")
        .join("");
    case "tildeAbove":
      return text
        .split("")
        .map((c) => c + "\u0303")
        .join("");
    case "crossBelow":
      return text
        .split("")
        .map((c) => c + "\u0353")
        .join("");

    // New combining mark styles
    case "heavyZalgo":
      return text
        .split("")
        .map((c) => {
          if (c === " ") return c;
          const up = [
            "\u030D",
            "\u030E",
            "\u0304",
            "\u0305",
            "\u033F",
            "\u0311",
            "\u0306",
            "\u0310",
            "\u0352",
            "\u0357",
            "\u0351",
            "\u0307",
            "\u0308",
            "\u030A",
            "\u0342",
            "\u0343",
            "\u0344",
            "\u034A",
            "\u034B",
            "\u034C",
            "\u0303",
            "\u0302",
            "\u030C",
            "\u0350",
            "\u0300",
            "\u0301",
            "\u030B",
            "\u030F",
            "\u0312",
            "\u0313",
            "\u0314",
            "\u033D",
            "\u0309",
            "\u0363",
            "\u0364",
            "\u0365",
            "\u0366",
            "\u0367",
            "\u0368",
            "\u0369",
            "\u036A",
            "\u036B",
            "\u036C",
            "\u036D",
            "\u036E",
            "\u036F",
            "\u0483",
            "\u0484",
            "\u0485",
            "\u0486",
            "\u0487",
          ];
          const mid = [
            "\u0315",
            "\u031B",
            "\u0340",
            "\u0341",
            "\u0358",
            "\u0321",
            "\u0322",
            "\u0327",
            "\u0328",
            "\u0334",
            "\u0335",
            "\u0336",
            "\u034F",
            "\u035C",
            "\u035D",
            "\u035E",
            "\u035F",
            "\u0360",
            "\u0362",
            "\u0338",
            "\u0337",
          ];
          const down = [
            "\u0316",
            "\u0317",
            "\u0318",
            "\u0319",
            "\u031C",
            "\u031D",
            "\u031E",
            "\u031F",
            "\u0320",
            "\u0324",
            "\u0325",
            "\u0326",
            "\u0329",
            "\u032A",
            "\u032B",
            "\u032C",
            "\u032D",
            "\u032E",
            "\u032F",
            "\u0330",
            "\u0331",
            "\u0332",
            "\u0333",
            "\u0339",
            "\u033A",
            "\u033B",
            "\u033C",
            "\u0345",
            "\u0347",
            "\u0348",
            "\u0349",
            "\u034D",
            "\u034E",
            "\u0353",
            "\u0354",
            "\u0355",
            "\u0356",
            "\u0359",
            "\u035A",
            "\u0323",
          ];
          let result = c;
          const count = 6 + Math.floor(Math.random() * 10);
          for (let i = 0; i < count; i++) {
            const r = Math.random();
            if (r < 0.4) result += up[Math.floor(Math.random() * up.length)];
            else if (r < 0.6)
              result += mid[Math.floor(Math.random() * mid.length)];
            else result += down[Math.floor(Math.random() * down.length)];
          }
          return result;
        })
        .join("");
    case "heavyCombining":
      return text
        .split("")
        .map((c) => {
          if (c === " ") return c;
          const marks = [
            "\u0300",
            "\u0301",
            "\u0302",
            "\u0303",
            "\u0304",
            "\u0305",
            "\u0306",
            "\u0307",
            "\u0308",
            "\u030A",
            "\u030B",
            "\u030C",
            "\u030D",
            "\u030E",
            "\u030F",
            "\u0310",
            "\u0311",
            "\u0312",
            "\u0313",
            "\u0314",
            "\u0316",
            "\u0317",
            "\u0318",
            "\u0319",
            "\u031C",
            "\u031D",
            "\u031E",
            "\u031F",
            "\u0320",
            "\u0321",
            "\u0322",
            "\u0324",
            "\u0325",
            "\u0326",
            "\u0327",
            "\u0328",
            "\u0329",
            "\u032A",
            "\u032B",
            "\u032C",
            "\u032D",
            "\u032E",
            "\u032F",
            "\u0330",
            "\u0331",
            "\u0332",
            "\u0333",
          ];
          let result = c;
          const count = 3 + Math.floor(Math.random() * 5);
          for (let i = 0; i < count; i++) {
            result += marks[Math.floor(Math.random() * marks.length)];
          }
          return result;
        })
        .join("");
    case "hebrewCombining":
      return text
        .split("")
        .map((c) => {
          if (c === " ") return c;
          const marks = [
            "\u0308",
            "\u0324",
            "\u0301",
            "\u0300",
            "\u0302",
            "\u030C",
            "\u030B",
            "\u030A",
            "\u0309",
            "\u0303",
          ];
          return (
            c +
            marks[Math.floor(Math.random() * marks.length)] +
            marks[Math.floor(Math.random() * marks.length)]
          );
        })
        .join("");

    // Boxed and bracket styles
    case "boxed":
      return text
        .split("")
        .map((c) => (c === " " ? c : `[${c.toUpperCase()}]`))
        .join("");
    case "lenticular":
      return text
        .split("")
        .map((c) => (c === " " ? c : `ã€${c.toUpperCase()}ã€‘`))
        .join("");
    case "regional":
      return text
        .toUpperCase()
        .split("")
        .map((c) => {
          if (c >= "A" && c <= "Z")
            return String.fromCodePoint(0x1f1e6 + c.charCodeAt(0) - 65);
          return c;
        })
        .join("");
    case "keycap":
      return text
        .split("")
        .map((c) => (c === " " ? c : c + "\uFE0F\u20E3"))
        .join("");
    case "negativeCircle":
      return text
        .toUpperCase()
        .split("")
        .map((c) => {
          if (c >= "A" && c <= "Z")
            return String.fromCodePoint(0x1f150 + c.charCodeAt(0) - 65);
          return c;
        })
        .join("");

    // CJK lookalike
    case "cjk": {
      const cjkMap: Record<string, string> = {
        a: "å‚",
        b: "ä¹ƒ",
        c: "åŒš",
        d: "åˆ€",
        e: "ä¹‡",
        f: "ä¸‹",
        g: "å¶",
        h: "å„",
        i: "å·¥",
        j: "ä¸",
        k: "é•¿",
        l: "ä¹š",
        m: "ä»",
        n: "å‡ ",
        o: "å£",
        p: "å°¸",
        q: "ã”¿",
        r: "å°º",
        s: "ä¸‚",
        t: "ä¸…",
        u: "å‡µ",
        v: "ãƒª",
        w: "å±±",
        x: "ä¹‚",
        y: "ä¸«",
        z: "ä¹™",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => cjkMap[c] || c)
        .join("");
    }
    case "cyrillic": {
      const cyrMap: Record<string, string> = {
        a: "Ğ”",
        b: "Ğ‘",
        c: "Ğ¦",
        d: "Ğ”",
        e: "Ğ­",
        f: "Ğ¤",
        g: "Ğ“",
        h: "Ğ",
        i: "Ğ˜",
        j: "Ğˆ",
        k: "Ğš",
        l: "Ğ›",
        m: "Ğœ",
        n: "Ğ˜",
        o: "Ğ",
        p: "ĞŸ",
        q: "Ğ¤",
        r: "Ğ¯",
        s: "Ğ…",
        t: "Ğ¢",
        u: "Ğ¦",
        v: "Ğ’",
        w: "Ğ¨",
        x: "Ğ¥",
        y: "Ğ§",
        z: "Ğ—",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => cyrMap[c] || c)
        .join("");
    }
    case "cherokee": {
      const cherokeeMap: Record<string, string> = {
        a: "áª",
        b: "á°",
        c: "áŸ",
        d: "á§",
        e: "á‹",
        f: "áµ",
        g: "á¶",
        h: "á»",
        i: "á¨",
        j: "á ",
        k: "á¦",
        l: "á",
        m: "á·",
        n: "á",
        o: "á¾",
        p: "á®",
        q: "á‡",
        r: "á’",
        s: "áš",
        t: "á¿",
        u: "áŒ",
        v: "á‰",
        w: "á³",
        x: "á²",
        y: "á½",
        z: "áƒ",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => cherokeeMap[c] || c)
        .join("");
    }
    case "ethiopic": {
      const ethMap: Record<string, string> = {
        a: "áŠ£",
        b: "á‰¥",
        c: "á‰½",
        d: "á‹µ",
        e: "áŠ¤",
        f: "á",
        g: "áŒ",
        h: "áˆ…",
        i: "áŠ¢",
        j: "áŒ…",
        k: "áŠ­",
        l: "áˆ",
        m: "áˆ",
        n: "áŠ•",
        o: "áŠ¦",
        p: "á•",
        q: "á‰…",
        r: "áˆ­",
        s: "áˆµ",
        t: "á‰µ",
        u: "áŠ¡",
        v: "á‰­",
        w: "á‹",
        x: "áˆ½",
        y: "á‹­",
        z: "á‹",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => ethMap[c] || c)
        .join("");
    }
    case "ethiopicCherokee": {
      const mixMap: Record<string, string> = {
        a: "ê“®",
        b: "ê“",
        c: "ê“š",
        d: "ê““",
        e: "ê“°",
        f: "ê“",
        g: "ê“–",
        h: "ê“§",
        i: "ê“²",
        j: "ê“™",
        k: "ê“˜",
        l: "ê“¡",
        m: "ê“Ÿ",
        n: "ê“ ",
        o: "ê“³",
        p: "ê“‘",
        q: "ê“˜",
        r: "ê“£",
        s: "ê“¢",
        t: "ê“”",
        u: "ê“´",
        v: "ê“¦",
        w: "ê“ª",
        x: "ê“«",
        y: "ê“¬",
        z: "ê“œ",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => mixMap[c] || c)
        .join("");
    }
    case "canadian": {
      const canMap: Record<string, string> = {
        a: "á—©",
        b: "á—·",
        c: "á‘•",
        d: "á—ª",
        e: "á—´",
        f: "á–´",
        g: "á˜œ",
        h: "á•¼",
        i: "á“°",
        j: "á’",
        k: "á–½",
        l: "á’ª",
        m: "á—°",
        n: "á˜‰",
        o: "á—",
        p: "á•ˆ",
        q: "á•´",
        r: "á–‡",
        s: "á”•",
        t: "áª",
        u: "á‘Œ",
        v: "á¯",
        w: "á—¯",
        x: "á™­",
        y: "á–»",
        z: "á—±",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => canMap[c] || c)
        .join("");
    }
    case "currency": {
      const curMap: Record<string, string> = {
        a: "â‚³",
        b: "à¸¿",
        c: "â‚µ",
        d: "Ã",
        e: "â‚¬",
        f: "â‚£",
        g: "á¶",
        h: "â±§",
        i: "Å‚",
        j: "J",
        k: "â‚­",
        l: "â± ",
        m: "â‚¥",
        n: "â‚¦",
        o: "Ã˜",
        p: "â‚±",
        q: "Q",
        r: "â±¤",
        s: "â‚´",
        t: "â‚®",
        u: "É„",
        v: "V",
        w: "â‚©",
        x: "Ó¾",
        y: "Â¥",
        z: "â±«",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => curMap[c] || c)
        .join("");
    }
    case "thaiLao": {
      const thaiMap: Record<string, string> = {
        a: "êª–",
        b: "êª‰",
        c: "êªš",
        d: "êªœ",
        e: "ê«€",
        f: "êªµ",
        g: "êª†",
        h: "ê«",
        i: "êª¿",
        j: "êªŠ",
        k: "êª—",
        l: "êª¶",
        m: "êª‘",
        n: "êª™",
        o: "êª®",
        p: "êª",
        q: "êª†",
        r: "êª¹",
        s: "êª«",
        t: "êª»",
        u: "êªŠ",
        v: "êªœ",
        w: "êª¡",
        x: "êª’",
        y: "êª—",
        z: "êª»",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => thaiMap[c] || c)
        .join("");
    }
    case "taiViet": {
      const tvMap: Record<string, string> = {
        a: "êª€",
        b: "êª‰",
        c: "êªŠ",
        d: "êª™",
        e: "êª«",
        f: "êªµ",
        g: "êª†",
        h: "êªš",
        i: "êª",
        j: "êªŠ",
        k: "êª—",
        l: "êª¶",
        m: "êª‘",
        n: "êª™",
        o: "êª®",
        p: "êª",
        q: "êª†",
        r: "êª¹",
        s: "êª«",
        t: "êª»",
        u: "êªŠ",
        v: "êªœ",
        w: "êª¡",
        x: "êª’",
        y: "êª—",
        z: "êª»",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => tvMap[c] || c)
        .join("");
    }
    case "runic":
      return mapChars(text.toLowerCase(), RUNIC_MAP);
    case "wingdingsDingbats":
      return toWingdings(text);
    case "matrix": {
      const mxMap: Record<string, string> = {
        a: "á—©",
        b: "á—·",
        c: "á‘•",
        d: "á—ª",
        e: "á—´",
        f: "á–´",
        g: "á¶",
        h: "á•¼",
        i: "I",
        j: "á’",
        k: "K",
        l: "á’ª",
        m: "á—°",
        n: "á‘",
        o: "O",
        p: "á‘­",
        q: "á‘«",
        r: "á–‡",
        s: "á•",
        t: "T",
        u: "á‘Œ",
        v: "á¯",
        w: "á—¯",
        x: "á™­",
        y: "Y",
        z: "á˜”",
      };
      return text
        .toLowerCase()
        .split("")
        .map((c) => mxMap[c] || c)
        .join("");
    }

    // Ransom note: randomly mix different font styles per character
    case "ransomNote":
      return text
        .split("")
        .map((c, i) => {
          if (c === " ") return c;
          const styles = [
            BOLD_MAP,
            ITALIC_MAP,
            GOTHIC_MAP,
            CURSIVE_MAP,
            MONOSPACE_MAP,
            BUBBLE_MAP,
            SUPERSCRIPT_MAP,
          ];
          const maps = [
            UNICODE_MAPS.fraktur,
            UNICODE_MAPS.boldFraktur,
            UNICODE_MAPS.script,
            UNICODE_MAPS.boldScript,
            UNICODE_MAPS.doubleStruck,
            UNICODE_MAPS.monospace,
            UNICODE_MAPS.sansBold,
            UNICODE_MAPS.sansItalic,
          ];
          const allMaps = [...styles, ...maps.filter(Boolean)];
          const selectedMap =
            allMaps[Math.floor(Math.random() * allMaps.length)];
          return mapChars(c, selectedMap);
        })
        .join("");

    // Themed scary/demonic styles (use existing maps + decorations)
    case "nightmareWhisper":
      return "ê§ " + mapChars(text.toLowerCase(), UNICODE_MAPS.fraktur) + " ê§‚";
    case "bloodDrip":
      return (
        text
          .split("")
          .map((c) => (c === " " ? c : mapChars(c, GOTHIC_MAP) + "Ì£"))
          .join("") + " ğŸ©¸"
      );
    case "shadowCrawl":
      return text
        .split("")
        .map((c) =>
          c === " " ? c : mapChars(c, UNICODE_MAPS.boldFraktur) + "\u0320",
        )
        .join("");
    case "skeletonScript":
      return "â˜  " + mapChars(text, UNICODE_MAPS.monospace) + " â˜ ";
    case "phantomOutline":
      return mapChars(text, UNICODE_MAPS.doubleStruck);
    case "graveyardGothic":
      return "âš° " + mapChars(text, GOTHIC_MAP) + " âš°";
    case "witchHex":
      return "â›¤ " + mapChars(text, UNICODE_MAPS.script) + " â›¤";
    case "vampireFang":
      return text
        .split("")
        .map((c) =>
          c === " " ? c : mapChars(c, UNICODE_MAPS.boldFraktur) + "\u0335",
        )
        .join("");
    case "ghostWhisper":
      return mapChars(text.toLowerCase(), UNICODE_MAPS.sansItalic);
    case "zombieDecay":
      return corruptText(mapChars(text, GOTHIC_MAP), 4);
    case "demonScript":
      return (
        "â›§ " + corruptText(mapChars(text, UNICODE_MAPS.boldFraktur), 3) + " â›§"
      );
    case "hauntedHouse":
      return "ğŸš " + mapChars(text, UNICODE_MAPS.fraktur) + " ğŸš";
    case "voodooMarks":
      return text
        .split("")
        .map((c) =>
          c === " " ? c : mapChars(c, UNICODE_MAPS.fraktur) + "\u0323\u0353",
        )
        .join("");
    case "skullBones":
      return "â˜  " + mapChars(text, UNICODE_MAPS.serifBold) + " â˜ ";
    case "werewolfClaw":
      return text
        .split("")
        .map((c) =>
          c === " " ? c : mapChars(c, UNICODE_MAPS.sansBold) + "\u0337",
        )
        .join("");
    case "evilEye":
      return "ğŸ‘ " + mapChars(text, UNICODE_MAPS.boldScript) + " ğŸ‘";
    case "digitalGlitch":
      return corruptText(text, 8);

    // Demonic themed styles
    case "shadowRealm":
      return text
        .split("")
        .map((c) =>
          c === " "
            ? c
            : mapChars(c, UNICODE_MAPS.boldFraktur) + "\u0316\u0332",
        )
        .join("");
    case "bloodRunes":
      return mapChars(text.toLowerCase(), RUNIC_MAP)
        .split("")
        .map((c) => (c === " " ? c : c + "\u0323"))
        .join("");
    case "lucifersHand":
      return "â›§ " + mapChars(text, UNICODE_MAPS.boldScript) + " â›§";
    case "beelzebub":
      return corruptText(mapChars(text, UNICODE_MAPS.boldFraktur), 5);
    case "baphomet":
      return "â›¤ " + mapChars(text, UNICODE_MAPS.fraktur) + " â›¤";
    case "necronomicon":
      return text
        .split("")
        .map((c) => (c === " " ? c : mapChars(c, GOTHIC_MAP) + "\u0300\u0316"))
        .join("");
    case "pentagram":
      return "â›§â›¤ " + mapChars(text, UNICODE_MAPS.boldFraktur) + " â›¤â›§";
    case "azazel":
      return corruptText(mapChars(text, UNICODE_MAPS.fraktur), 7);
    case "lilith":
      return "â™± " + mapChars(text, UNICODE_MAPS.script) + " â™±";
    case "abaddon":
      return text
        .split("")
        .map((c) =>
          c === " "
            ? c
            : mapChars(c, UNICODE_MAPS.boldFraktur) + "\u0334\u0300",
        )
        .join("");
    case "mammon":
      return mapChars(text.toLowerCase(), UNICODE_MAPS.doubleStruck);
    case "leviathan":
      return "ğŸ " + corruptText(mapChars(text, GOTHIC_MAP), 3) + " ğŸ";

    // Gothic themed styles
    case "victorian":
      return "â¦ " + mapChars(text, UNICODE_MAPS.script) + " â¦";
    case "cathedralStone":
      return "â›ª " + mapChars(text, UNICODE_MAPS.fraktur) + " â›ª";

    // Heavy/Block styles
    case "heavyBlock":
      return text
        .split("")
        .map((c) => (c === " " ? c : "â–ˆ" + c.toUpperCase() + "â–ˆ"))
        .join("");
    case "boldWide":
      return mapChars(text, BOLD_MAP).split("").join(" ");
    case "sansSpaced":
      return mapChars(text, UNICODE_MAPS.sansBold).split("").join(" ");

    case "hearts":
      return text.split("").join(" â™¥ ");
    case "sparkle":
      return text.split("").join(" âœ¨ ");
    case "wavy":
      return text.split("").join(" ã€° ");
    case "wingdings":
      return toWingdings(text);
    case "mixedFancy":
      return text
        .split("")
        .map((c, i) =>
          i % 2 === 0
            ? mapChars(c, UNICODE_MAPS.fraktur)
            : mapChars(c, UNICODE_MAPS.script),
        )
        .join("");

    // Gaming Presets (Mapped)
    case "retro_press":
    case "retro_vcr":
    case "retro_joy":
    case "retro_arcade":
    case "scifi_elec":
    case "scifi_exo":
    case "game_mine":
    case "game_cod":
      return mapChars(text, MONOSPACE_MAP);

    case "esports_bebas":
    case "esports_teko":
    case "esports_bungee":
    case "esports_raj":
    case "game_fort":
    case "game_gta":
    case "sansBold":
      return mapChars(text, UNICODE_MAPS.sansBold);
    case "sansItalic":
      return mapChars(text, UNICODE_MAPS.sansItalic);
    case "sansBoldItalic":
      return mapChars(text, UNICODE_MAPS.sansBoldItalic);

    case "game_poke":
      return mapChars(text, UNICODE_MAPS.doubleStruck);

    case "esports_industry":
      return mapChars(text, ITALIC_MAP);

    case "scifi_orb":
    case "scifi_audio":
      return mapChars(text, UNICODE_MAPS.fullwidth);

    case "horror_creep":
    case "horror_nos":
    case "fantasy_med":
      return mapChars(text, UNICODE_MAPS.fraktur);

    case "fantasy_cinzel":
      return mapChars(text, UNICODE_MAPS.serifBold);

    case "horror_glitch":
      return corruptText(text, 15);

    default:
      return text;
  }
}

export function transformText(
  text: string,
  slug: string,
  options: TransformOptions = {},
): string {
  if (!text) return "";

  const {
    intensity = 5,
    spacing = 1,
    uppercase = false,
    style = "default",
    decoration = "",
    customSettings = {},
  } = options;

  let workingText = uppercase ? text.toUpperCase() : text;
  const s = slug.toLowerCase();

  // Social & Gaming Enhanced Logic
  if (s === "discord-font") {
    const fontStyle = customSettings.fontStyle || "fraktur";
    let result = applyFontStyle(workingText, fontStyle);

    if (customSettings.spoiler) result = `||${result}||`;
    if (customSettings.markdown) {
      // Markdown Code Block
      result = "```" + result + "```";
    }
    return result;
  }

  if (s === "instagram-font") {
    return applyFontStyle(workingText, customSettings.style || "sansBold");
  }

  if (s === "tiktok-font") {
    return applyFontStyle(workingText, customSettings.style || "serifBold");
  }

  if (s === "facebook-font") {
    return applyFontStyle(workingText, customSettings.style || "sansBold");
  }

  if (s === "gaming-font") {
    return applyFontStyle(workingText, customSettings.game || "game_fort");
  }

  if (s === "fortnite-font") {
    return applyFontStyle(workingText, customSettings.style || "sansBold");
  }

  if (s === "twitter-font") {
    const fontStyle = customSettings.fontStyle || "sansBold";
    let result = applyFontStyle(workingText, fontStyle);

    if (customSettings.thread) {
      // Split into 280 char chunks (simple implementation)
      const chunks = result.match(/.{1,280}/g) || [result];
      return chunks
        .map((c, i) => `${c} [${i + 1}/${chunks.length}]`)
        .join("\n\n---\n\n");
    }
    return result;
  }

  if (s === "gaming-font") {
    const gameStyle = customSettings.game || "game_fort";
    return applyFontStyle(workingText, gameStyle);
  }

  if (s === "fortnite-font") {
    // User specifically complained about format.
    // We map it to "sansBold" (Burbank-ish)
    return applyFontStyle(workingText, "sansBold");
  }

  // ... Original switch for other tools ...
  switch (s) {
    case "cursed-text":
    case "corrupted-text": {
      const fontStyle = customSettings.fontStyle || "zalgo";
      const baseIntensity = customSettings.intensity || intensity;

      // Apply font style first
      let styledText = workingText;

      // Font style character maps for various Unicode ranges
      const cursedFontMaps: Record<string, Record<string, string>> = {
        cyrillic: {
          a: "Ñ¦",
          b: "Ğª",
          c: "Ò€",
          d: "Ô€",
          e: "Ğ„",
          f: "Ò’",
          g: "ÔŒ",
          h: "Ò¢",
          i: "Ğ†",
          j: "Ğˆ",
          k: "Òš",
          l: "Ô®",
          m: "Ğœ",
          n: "ÒŠ",
          o: "Ó¨",
          p: "Ò",
          q: "Ò¨",
          r: "Ğ¯",
          s: "Ğ…",
          t: "Ò¬",
          u: "Ğ¦",
          v: "Ñ´",
          w: "Ğ¨",
          x: "Ò–",
          y: "Ò°",
          z: "Ò˜",
        },
        tibetan: {
          a: "à½¨",
          b: "à½–",
          c: "à½…",
          d: "à½‘",
          e: "à½¨à½º",
          f: "à½•",
          g: "à½‚",
          h: "à½§",
          i: "à½¨à½²",
          j: "à½‡",
          k: "à½€",
          l: "à½£",
          m: "à½˜",
          n: "à½“",
          o: "à½¨à½¼",
          p: "à½”",
          q: "à½€à¾­",
          r: "à½¢",
          s: "à½¦",
          t: "à½",
          u: "à½¨à½´",
          v: "à½",
          w: "à½",
          x: "à½€à¾µ",
          y: "à½¡",
          z: "à½Ÿ",
        },
        ethiopic: {
          a: "áŠ£",
          b: "á‰¥",
          c: "á‰½",
          d: "á‹µ",
          e: "áŠ¤",
          f: "á",
          g: "áŒ",
          h: "áˆ…",
          i: "áŠ¢",
          j: "áŒ…",
          k: "áŠ­",
          l: "áˆ",
          m: "áˆ",
          n: "áŠ•",
          o: "áŠ¦",
          p: "á•",
          q: "á‰…",
          r: "áˆ­",
          s: "áˆµ",
          t: "á‰µ",
          u: "áŠ¡",
          v: "á‰­",
          w: "á‹",
          x: "áˆ½",
          y: "á‹­",
          z: "á‹",
        },
        vai: {
          a: "ê”€",
          b: "ê•«",
          c: "ê”²",
          d: "ê•’",
          e: "ê—‚",
          f: "ê•˜",
          g: "ê•¬",
          h: "ê–…",
          i: "ê”¤",
          j: "ê•½",
          k: "ê”…",
          l: "ê•",
          m: "ê•®",
          n: "ê•¯",
          o: "ê–‚",
          p: "ê•¶",
          q: "ê”³",
          r: "ê•ƒ",
          s: "ê–¬",
          t: "ê•§",
          u: "ê–„",
          v: "ê–†",
          w: "ê–‡",
          x: "ê”µ",
          y: "ê–",
          z: "ê–“",
        },
        canadian: {
          a: "áŠ",
          b: "á‘Š",
          c: "á‘²",
          d: "á‘",
          e: "á",
          f: "á–´",
          g: "á’",
          h: "á•¼",
          i: "áƒ",
          j: "á’",
          k: "á•®",
          l: "á’¡",
          m: "á’ª",
          n: "á“€",
          o: "á…",
          p: "á‘­",
          q: "á•¿",
          r: "á•†",
          s: "á”…",
          t: "á‘¦",
          u: "á†",
          v: "á•“",
          w: "á§",
          x: "á•",
          y: "á”¨",
          z: "á”‘",
        },
        cherokee: {
          a: "áª",
          b: "á°",
          c: "á¨",
          d: "á—",
          e: "á¡",
          f: "á²",
          g: "á³",
          h: "á¥",
          i: "á¢",
          j: "á¤",
          k: "á¦",
          l: "á",
          m: "á·",
          n: "á",
          o: "á£",
          p: "á®",
          q: "á†",
          r: "á’",
          s: "á",
          t: "á–",
          u: "á¬",
          v: "á¤",
          w: "á³",
          x: "áŒ",
          y: "á±",
          z: "áƒ",
        },
        cjk: {
          a: "ä¸¹",
          b: "ä¹ƒ",
          c: "åŒš",
          d: "åˆ€",
          e: "ä¹‡",
          f: "ä¸‹",
          g: "å‘‚",
          h: "å„",
          i: "å·¥",
          j: "ãƒ¨",
          k: "ç‰‡",
          l: "ã—",
          m: "å†Š",
          n: "ã‚Œ",
          o: "å£",
          p: "å°¸",
          q: "ã”¿",
          r: "å°º",
          s: "ä¸‚",
          t: "ä¸",
          u: "å‡µ",
          v: "ãƒª",
          w: "å±±",
          x: "ãƒ¡",
          y: "ã„š",
          z: "ä¹™",
        },
      };

      // Apply font style if not using zalgo base
      if (
        fontStyle !== "zalgo" &&
        fontStyle !== "extendedDiacritical" &&
        fontStyle !== "halfMarks" &&
        fontStyle !== "enclosingMarks"
      ) {
        const fontMap =
          cursedFontMaps[fontStyle] || UNICODE_MAPS[fontStyle] || {};
        if (Object.keys(fontMap).length > 0) {
          styledText = mapChars(workingText, fontMap);
        }
      }

      // Apply corruption with varying combining characters based on font style
      const combiningMarks: Record<string, string[]> = {
        zalgo: [
          "\u0300",
          "\u0301",
          "\u0302",
          "\u0303",
          "\u0304",
          "\u0305",
          "\u0306",
          "\u0307",
          "\u0308",
          "\u0309",
          "\u030A",
          "\u030B",
          "\u030C",
          "\u030D",
          "\u030E",
          "\u030F",
          "\u0310",
          "\u0311",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u0315",
          "\u031A",
          "\u031B",
          "\u033D",
          "\u033E",
          "\u033F",
          "\u0340",
          "\u0341",
          "\u0342",
          "\u0343",
          "\u0344",
          "\u0346",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0350",
          "\u0351",
          "\u0352",
          "\u0357",
          "\u035B",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
        ],
        extendedDiacritical: [
          "\u1AB0",
          "\u1AB1",
          "\u1AB2",
          "\u1AB3",
          "\u1AB4",
          "\u1AB5",
          "\u1AB6",
          "\u1AB7",
          "\u1AB8",
          "\u1AB9",
          "\u1ABA",
          "\u1ABB",
          "\u1ABC",
          "\u1ABD",
        ],
        halfMarks: [
          "\uFE20",
          "\uFE21",
          "\uFE22",
          "\uFE23",
          "\uFE24",
          "\uFE25",
          "\uFE26",
        ],
        enclosingMarks: [
          "\u20DD",
          "\u20DE",
          "\u20DF",
          "\u20E0",
          "\u20E2",
          "\u20E3",
          "\u20E4",
        ],
      };

      const marks = combiningMarks[fontStyle] || combiningMarks.zalgo;

      return styledText
        .split("")
        .map((char) => {
          if (char === " ") return char;
          let result = char;
          const numMarks = Math.floor(Math.random() * baseIntensity) + 1;
          for (let i = 0; i < numMarks; i++) {
            result += marks[Math.floor(Math.random() * marks.length)];
          }
          return result;
        })
        .join("");
    }
    case "zalgo-text": {
      const fontStyle = customSettings.fontStyle || "classic";
      const { up, middle, down, intensity: customIntensity } = customSettings;
      const finalIntensity = customIntensity || intensity;

      // Apply font style first if not classic
      let styledText = workingText;
      if (fontStyle !== "classic") {
        styledText = applyFontStyle(workingText, fontStyle);
      }

      if (up !== undefined || middle !== undefined || down !== undefined) {
        return corruptText(styledText, finalIntensity, {
          up: up ?? 0,
          middle: middle ?? 0,
          down: down ?? 0,
        });
      }
      return corruptText(styledText, finalIntensity);
    }
    case "demonic-text": {
      const demonicStyle = customSettings.demonicStyle || "gothic";
      const darkness = customSettings.darkness || 5;
      const addCross = customSettings.invertedCross !== false;

      // Apply the selected demonic style via applyFontStyle
      let result = applyFontStyle(workingText, demonicStyle);

      // Special cases that need additional corruption
      if (
        demonicStyle === "hellfire" ||
        demonicStyle === "abyss" ||
        demonicStyle === "azazel" ||
        demonicStyle === "beelzebub"
      ) {
        result = corruptText(result, Math.ceil(darkness / 2));
      } else if (darkness > 5) {
        // Apply corruption at higher darkness levels
        result = corruptText(result, Math.ceil((darkness - 5) / 3));
      }

      if (addCross) {
        const symbols = ["â€ ", "â€¡", "â›§", "â˜ ", "âš°", "â™±", "â›¤", "â˜¥", "â¸¸"];
        result = result
          .split("")
          .map((c, i) =>
            i % Math.max(8 - Math.floor(darkness / 2), 2) === 0 && c !== " "
              ? c + symbols[Math.floor(Math.random() * symbols.length)]
              : c,
          )
          .join("");
      }
      return result;
    }
    case "scary-text": {
      const fontStyle = customSettings.fontStyle || "fraktur";
      const fear = customSettings.fear || 5;

      // Apply the selected scary font style
      let result = applyFontStyle(workingText, fontStyle);

      // Apply corruption based on fear level
      if (fear > 2) {
        result = corruptText(result, Math.ceil(fear / 2));
      }

      // At high fear levels, add extra dread symbols
      if (fear > 10) {
        const dreadSymbols = ["Ì·", "Ì¸", "Ì¶", "Ìµ", "Ì´"];
        result = result
          .split("")
          .map((c) => {
            if (c === " ") return c;
            if (Math.random() < (fear - 10) / 15) {
              return (
                c +
                dreadSymbols[Math.floor(Math.random() * dreadSymbols.length)]
              );
            }
            return c;
          })
          .join("");
      }

      return result;
    }
    case "gothic-font": {
      const gothicStyle = customSettings.gothicStyle || "fraktur";
      const addOrnaments = customSettings.ornaments === true;

      // Use applyFontStyle for all gothic styles
      let result = applyFontStyle(workingText, gothicStyle);

      if (addOrnaments) {
        const ornamentPairs = [
          ["à¼º ", " à¼»"],
          ["â¦ ", " â¦"],
          ["ê§ ", " ê§‚"],
          ["âšœ ", " âšœ"],
          ["âœ¦ ", " âœ¦"],
        ];
        const pair =
          ornamentPairs[Math.floor(Math.random() * ornamentPairs.length)];
        result = pair[0] + result + pair[1];
      }
      return result;
    }

    case "glitch-text": {
      const fontStyle = customSettings.fontStyle || "standard";
      const glitchLevel = customSettings.glitchLevel || 5;
      const gType = customSettings.glitchType || "digital";

      // Apply font style first if not standard
      let styledText = workingText;
      if (fontStyle !== "standard") {
        styledText = applyFontStyle(workingText, fontStyle);
      }

      // Glitch characters for various types
      const glitchChars: Record<string, string[]> = {
        digital: ["â–‘", "â–’", "â–“", "â–ˆ", "â–„", "â–€", "â– ", "â–¡", "â–ª", "â–«"],
        vhs: ["â–“", "â–’", "â–‘", "â–ˆ", "â–Œ", "â–", "â–€", "â–„"],
        static: ["â–‘", "â–’", "â–“", "Â·", ":", ";", "!", "?", "*"],
        matrix: ["0", "1", "ãƒ¼", "ï½œ", "ï¼", "ï¼¼"],
        cyber: ["âŸ¨", "âŸ©", "âŒˆ", "âŒ‰", "âŒŠ", "âŒ‹", "âŸª", "âŸ«", "â¦ƒ", "â¦„"],
      };

      const glitchSet = glitchChars[gType] || glitchChars.digital;
      const glitchProbability = glitchLevel / 20; // 0.05 to 0.5

      return styledText
        .split("")
        .map((c) => {
          if (c === " ") return c;

          // Random glitch character insertion based on level
          if (Math.random() < glitchProbability) {
            const glitchChar =
              glitchSet[Math.floor(Math.random() * glitchSet.length)];
            if (Math.random() < 0.5) {
              return glitchChar;
            } else {
              return c + glitchChar;
            }
          }

          // Apply corruption based on glitch level
          if (Math.random() < glitchProbability * 0.5) {
            return corruptText(c, Math.ceil(glitchLevel / 3));
          }

          return c;
        })
        .join("");
    }

    // ... keep other existing cases ...
    // Reuse applyFontStyle for social mappings that overlap
    case "instagram-font":
      // User reported "Mistake in Preview".
      // The font logic itself is usually Script or Sans.
      // We will map it to what the standard Instagram tool expects (usually variety, but defaults to Script/Bold)
      // I'll leave the original logic OR use applyFontStyle if I can mapping 'instagram' to something.
      // Original logic was mapChars(CURSIVE_MAP) + decorations.
      const base = mapChars(workingText, CURSIVE_MAP);
      const density = customSettings.density || 0;
      const symbols = ["âœ¨", "ğŸŒ¸", "âœ§", "â€", "â˜…"];
      if (density > 0) {
        return base
          .split("")
          .map((c) =>
            Math.random() < density * 0.1
              ? c + symbols[Math.floor(Math.random() * symbols.length)]
              : c,
          )
          .join("");
      }
      return base;

    // STYLE & FANCY TOOLS
    case "fancy-font": {
      const fontStyle = customSettings.fontStyle || "script";
      const fancyLevel = customSettings.fancy_level || 5;
      const density = customSettings.density || 2;

      let result = applyFontStyle(workingText, fontStyle);

      const decorSymbols = [
        "âœ§",
        "âœ¦",
        "â˜…",
        "â˜†",
        "â‹",
        "âŠ",
        "â‰",
        "âˆ",
        "âœ¿",
        "â€",
        "âšœ",
        "â™”",
        "â™•",
        "à¼’",
        "â§",
      ];
      const insertFreq = Math.max(8 - Math.floor(density), 1);

      if (fancyLevel >= 3) {
        result = result
          .split("")
          .map((c, i) => {
            if (c === " ") return c;
            if (i % insertFreq === 0) {
              return (
                c +
                decorSymbols[Math.floor(Math.random() * decorSymbols.length)]
              );
            }
            return c;
          })
          .join("");
      }

      if (fancyLevel >= 7) {
        const frames = [
          ["à¼º ", " à¼»"],
          ["â® ", " â¯"],
          ["â° ", " â±"],
          ["Â«Â« ", "Â»Â»"],
          ["â•”â• ", " â•â•—"],
          ["âœ¦ ", " âœ¦"],
          ["âŠ± ", " âŠ°"],
        ];
        const frame = frames[Math.floor(Math.random() * frames.length)];
        result = frame[0] + result + frame[1];
      }

      return result;
    }
    case "aesthetic-font": {
      const fontStyle = customSettings.fontStyle || "script";
      const vibe = customSettings.vibe || "vaporwave";

      let result = applyFontStyle(workingText, fontStyle);

      const vibeDecorations: Record<
        string,
        { prefix: string; suffix: string }
      > = {
        vaporwave: { prefix: "âœ§Ëšâ‚Š ", suffix: " â‚ŠËšâœ§" },
        soft: { prefix: "â˜ï¸ ", suffix: " â˜ï¸" },
        grunge: { prefix: "âœ— ", suffix: " âœ—" },
        dark: { prefix: "â˜¾ ", suffix: " â˜¾" },
        celestial: { prefix: "â˜†.ã€‚.:* ", suffix: " *:.ã€‚.â˜†" },
        cottagecore: { prefix: "ğŸŒ¿ğŸ„ ", suffix: " ğŸ„ğŸŒ¿" },
        y2k: { prefix: "âœ°â‹† ", suffix: " â‹†âœ°" },
        kawaii: { prefix: "â™¡âœ§Ëš ", suffix: " Ëšâœ§â™¡" },
        cyberpunk: { prefix: "âŸ¨âŒˆ ", suffix: " âŒ‰âŸ©" },
        fairycore: { prefix: "âœ¦Ëšâº ", suffix: " âºËšâœ¦" },
        royalcore: { prefix: "â™”âšœ ", suffix: " âšœâ™”" },
        angelcore: { prefix: "â™¡âœ° ", suffix: " âœ°â™¡" },
        witchcore: { prefix: "â˜½â›¤ ", suffix: " â›¤â˜½" },
        minimal: { prefix: "", suffix: "" },
      };

      const decoration = vibeDecorations[vibe] || vibeDecorations.vaporwave;
      return decoration.prefix + result + decoration.suffix;
    }
    case "stylish-font": {
      const fontStyle = customSettings.fontStyle || "script";
      const addDecorations = customSettings.decorations !== false;

      let result = applyFontStyle(workingText, fontStyle);

      if (addDecorations) {
        const decorPairs = [
          ["â™” ", " â™•"],
          ["âœ§ ", " âœ§"],
          ["â˜… ", " â˜…"],
          ["â– ", " â–"],
          ["âšœ ", " âšœ"],
          ["â™› ", " â™›"],
          ["âœ¦ ", " âœ¦"],
          ["â§ ", " â§"],
          ["à¼º ", " à¼»"],
          ["â® ", " â¯"],
          ["â° ", " â±"],
        ];
        const pair = decorPairs[Math.floor(Math.random() * decorPairs.length)];
        result = pair[0] + result + pair[1];
      }

      return result;
    }
    case "cute-font": {
      const fontStyle = customSettings.fontStyle || "bubble";
      const cuteStyle = customSettings.cuteStyle || "kawaii";
      const addEmoticons = customSettings.emoticons !== false;

      let result =
        fontStyle === "bubble"
          ? mapChars(workingText, BUBBLE_MAP)
          : applyFontStyle(workingText, fontStyle);

      const cuteEmoticons: Record<string, string[]> = {
        kawaii: ["(â—•â€¿â—•)", "(â—•á´—â—•âœ¿)", "âœ¿", "â€", "ğŸŒ¸", "(â— â€¿â— )", "â™¡"],
        bubbly: ["â€¢á´—â€¢", "â—¦â€¿â—¦", "â—‹", "â—", "âšª", "âŠ™", "â—¯"],
        sweet: ["â™¡", "â™¥", "â¤", "ğŸ’•", "ğŸ¬", "ğŸ­", "ğŸ’—"],
        sparkle: ["âœ¨", "â‹†", "âœ§", "â˜…", "ğŸ’«", "âœ¦", "â­"],
        flower: ["ğŸŒ¸", "âœ¿", "â€", "ğŸŒº", "ğŸŒ»", "ğŸŒ¹", "ğŸ’"],
        star: ["â­", "â˜…", "â˜†", "âœ¦", "âœ§", "ğŸŒŸ", "âœ¯"],
        heart: ["ğŸ’•", "ğŸ’—", "ğŸ’–", "ğŸ’˜", "ğŸ’", "ğŸ’", "â™¡"],
        cloud: ["â˜ï¸", "âœ§", "Ëš", "â‹†", "â˜", "â‹…", "Â·"],
        moon: ["ğŸŒ™", "â˜½", "âœ§", "Ëš", "â‹†", "â˜¾", "âœ¦"],
        rainbow: ["ğŸŒˆ", "âœ§", "â‹†", "Ëš", "â˜…", "â˜†", "âœ¦"],
        candy: ["ğŸ­", "ğŸ¬", "ğŸ©", "ğŸ§", "ğŸ°", "ğŸ‚", "ğŸª"],
        bear: ["Ê•â€¢á´¥â€¢Ê”", "Ê• áµ”á´¥áµ” Ê”", "Ê•â™¥á´¥â™¥Ê”", "(â—•á´—â—•)"],
        bunny: ["(ã…‡ã……ã…‡)", "(\\ /)", "ğŸ°", "ğŸ‡"],
        cat: ["(=^ãƒ»^=)", "á“šá˜á—¢", "ğŸ±", "(=^â—¡^=)"],
        butterfly: ["ğŸ¦‹", "âœ§", "âœ¦", "Ëš", "â‹†", "Â·"],
        unicorn: ["ğŸ¦„", "âœ¨", "ğŸŒˆ", "â­", "ğŸ’«", "âœ§"],
      };

      const emoticons = cuteEmoticons[cuteStyle] || cuteEmoticons.kawaii;

      if (addEmoticons) {
        const prefix = emoticons[Math.floor(Math.random() * emoticons.length)];
        const suffix = emoticons[Math.floor(Math.random() * emoticons.length)];
        result = prefix + " " + result + " " + suffix;
      }

      return result;
    }
    case "calligraphy-font": {
      const fontStyle = customSettings.fontStyle || "script";
      const addFlourishes = customSettings.flourishes === true;

      let result = applyFontStyle(workingText, fontStyle);

      if (addFlourishes) {
        const flourishPairs = [
          ["â§ ", " â§"],
          ["â˜™ ", " â§"],
          ["â• ", " â•"],
          ["â¦ ", " â¦"],
          ["âœ¿ ", " âœ¿"],
          ["âœ¾ ", " âœ¾"],
          ["â‹ ", " â‹"],
          ["âŠ± ", " âŠ°"],
        ];
        const pair =
          flourishPairs[Math.floor(Math.random() * flourishPairs.length)];
        result = pair[0] + result + pair[1];
      }

      return result;
    }
    case "cursive-font": {
      const fontStyle = customSettings.fontStyle || "script";
      return applyFontStyle(workingText, fontStyle);
    }

    // TEXT TOOLS
    case "bold-text": {
      const fontStyle = customSettings.fontStyle || "serifBold";
      const combineItalic = customSettings.italic === true;

      if (combineItalic) {
        // Bold + Italic combos
        if (fontStyle === "sansBold" || fontStyle === "sansItalic") {
          return applyFontStyle(workingText, "sansBoldItalic");
        }
        return applyFontStyle(workingText, "mathBoldItalic");
      }

      return applyFontStyle(workingText, fontStyle);
    }
    case "italic-text": {
      const fontStyle = customSettings.fontStyle || "serifItalic";
      const combineBold = customSettings.bold === true;

      if (combineBold) {
        if (fontStyle === "sansItalic" || fontStyle === "sansBold") {
          return applyFontStyle(workingText, "sansBoldItalic");
        }
        return applyFontStyle(workingText, "mathBoldItalic");
      }

      return applyFontStyle(workingText, fontStyle);
    }
    case "underline-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const style = customSettings.style || "single";

      let base =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      const underlineChars: Record<string, string> = {
        single: "\u0332",
        double: "\u0333",
        wavy: "\u0330",
        diaeresis: "\u0324",
        ring: "\u0325",
        caron: "\u032C",
        bridge: "\u032A",
        invertedBridge: "\u033A",
        seagull: "\u033C",
        verticalLine: "\u0329",
      };

      const char = underlineChars[style] || underlineChars.single;
      return [...base].map((c) => c + char).join("");
    }
    case "strikethrough-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const position = customSettings.position || "center";
      const doubleStrike = customSettings.double === true;

      let base =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      const strikeChars: Record<string, string> = {
        center: "\u0336",
        high: "\u0305",
        low: "\u0332",
        short: "\u0335",
        diagonal: "\u0338",
        tilde: "\u0334",
        x: "\u20E6",
        slash: "\u0337",
      };

      const char = strikeChars[position] || strikeChars.center;

      if (doubleStrike) {
        return [...base].map((c) => c + char + char).join("");
      }
      return [...base].map((c) => c + char).join("");
    }
    case "upside-down-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const angle = customSettings.angle || "180";
      const mirrorCombo = customSettings.mirror === true;

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (angle === "90") return text.split("").join("\n");
      if (angle === "270") return text.split("").reverse().join("\n");

      let result = mapChars(text, UPSIDE_DOWN_MAP).split("").reverse().join("");

      if (mirrorCombo) {
        result = mapChars(result, FLIP_TEXT_MAP);
      }

      return result;
    }
    case "mirror-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const direction = customSettings.direction || "horizontal";

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (direction === "vertical") {
        return mapChars(mapChars(text, FLIP_TEXT_MAP), UPSIDE_DOWN_MAP);
      } else if (direction === "both") {
        return mapChars(text, UPSIDE_DOWN_MAP).split("").reverse().join("");
      } else if (direction === "wordReverse") {
        return text.split(" ").reverse().join(" ");
      } else if (direction === "lineReverse") {
        return text.split("\n").reverse().join("\n");
      }
      return mapChars(text, FLIP_TEXT_MAP).split("").reverse().join("");
    }
    case "small-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const mode = customSettings.mode || "super";

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (mode === "sub") {
        return mapChars(text, SUBSCRIPT_MAP);
      } else if (mode === "smallcaps") {
        return applyFontStyle(text, "smallCaps");
      } else if (mode === "superSmall") {
        // Alternate words: superscript then small caps
        return text
          .split(" ")
          .map((word, i) =>
            i % 2 === 0
              ? mapChars(word, SUPERSCRIPT_MAP)
              : applyFontStyle(word, "smallCaps"),
          )
          .join(" ");
      } else if (mode === "subSmall") {
        return text
          .split(" ")
          .map((word, i) =>
            i % 2 === 0
              ? mapChars(word, SUBSCRIPT_MAP)
              : applyFontStyle(word, "smallCaps"),
          )
          .join(" ");
      } else if (mode === "alternate") {
        return [...text]
          .map((c, i) =>
            i % 2 === 0 ? SUPERSCRIPT_MAP[c] || c : SUBSCRIPT_MAP[c] || c,
          )
          .join("");
      }
      return mapChars(text, SUPERSCRIPT_MAP);
    }
    case "tiny-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const tinyType = customSettings.type || "super";

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (tinyType === "sub") {
        return mapChars(text, SUBSCRIPT_MAP);
      } else if (tinyType === "smallcaps") {
        return applyFontStyle(text, "smallCaps");
      } else if (tinyType === "alternate") {
        return [...text]
          .map((c, i) =>
            i % 2 === 0 ? SUPERSCRIPT_MAP[c] || c : SUBSCRIPT_MAP[c] || c,
          )
          .join("");
      } else if (tinyType === "superCaps") {
        return mapChars(text.toUpperCase(), SUPERSCRIPT_MAP);
      } else if (tinyType === "subCaps") {
        return mapChars(text.toUpperCase(), SUBSCRIPT_MAP);
      }
      return mapChars(text, SUPERSCRIPT_MAP);
    }
    case "superscript": {
      const fontStyle = customSettings.fontStyle || "none";
      const mode = customSettings.mode || "super";

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (mode === "sub") {
        return mapChars(text, SUBSCRIPT_MAP);
      } else if (mode === "alternate") {
        return [...text]
          .map((c, i) =>
            i % 2 === 0 ? SUPERSCRIPT_MAP[c] || c : SUBSCRIPT_MAP[c] || c,
          )
          .join("");
      } else if (mode === "wordAlternate") {
        return text
          .split(" ")
          .map((word, i) =>
            i % 2 === 0
              ? mapChars(word, SUPERSCRIPT_MAP)
              : mapChars(word, SUBSCRIPT_MAP),
          )
          .join(" ");
      }
      return mapChars(text, SUPERSCRIPT_MAP);
    }
    case "big-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const gap = customSettings.gap || 1;
      const bigStyle = customSettings.style || "upper";

      let result = workingText;

      // Apply case style first
      if (bigStyle === "upper") {
        result = result.toUpperCase();
      } else if (bigStyle === "bold") {
        result = mapChars(result.toUpperCase(), BOLD_MAP);
      } else if (bigStyle === "wide") {
        result = result
          .toUpperCase()
          .split("")
          .map((c) => {
            const code = c.charCodeAt(0);
            return code >= 33 && code <= 126
              ? String.fromCharCode(code + 0xfee0)
              : c;
          })
          .join("");
      } else if (bigStyle === "lower") {
        result = result.toLowerCase();
      } else if (bigStyle === "alternating") {
        result = result
          .split("")
          .map((c, i) => (i % 2 === 0 ? c.toLowerCase() : c.toUpperCase()))
          .join("");
      } else if (bigStyle === "random") {
        result = result
          .split("")
          .map((c) => (Math.random() > 0.5 ? c.toUpperCase() : c.toLowerCase()))
          .join("");
      } else if (bigStyle === "title") {
        result = result.toLowerCase().replace(/\b\w/g, (c) => c.toUpperCase());
      }

      // Apply font style
      if (fontStyle !== "none") {
        result = applyFontStyle(result, fontStyle);
      }

      return result.split("").join(" ".repeat(gap));
    }
    case "space-remover": {
      const fontStyle = customSettings.fontStyle || "none";
      const mode = customSettings.mode || "all";

      let result = workingText;

      if (mode === "extra") {
        result = result.replace(/\s+/g, " ");
      } else if (mode === "trim") {
        result = result.trim();
      } else if (mode === "dash") {
        result = result.replace(/\s+/g, "-");
      } else if (mode === "underscore") {
        result = result.replace(/\s+/g, "_");
      } else {
        result = result.replace(/\s/g, "");
      }

      if (fontStyle !== "none") {
        result = applyFontStyle(result, fontStyle);
      }
      return result;
    }
    case "text-cleaner": {
      const fontStyle = customSettings.fontStyle || "none";
      const cleanType = customSettings.cleanType || "special";
      const preserveSpaces = customSettings.preserveSpaces !== false;

      let result = workingText;

      if (cleanType === "special") {
        result = result.replace(/[^\w\s]/g, "");
      } else if (cleanType === "numbers") {
        result = result.replace(/[0-9]/g, "");
      } else if (cleanType === "punctuation") {
        result = result.replace(/[.,!?;:'"()\-\[\]{}]/g, "");
      } else if (cleanType === "all") {
        result = result.replace(/[^a-zA-Z\s]/g, "");
      } else if (cleanType === "emojis") {
        result = result.replace(
          /[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2702}-\u{27B0}\u{24C2}-\u{1F251}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu,
          "",
        );
      } else if (cleanType === "html") {
        result = result.replace(/<[^>]*>/g, "");
      } else if (cleanType === "urls") {
        result = result.replace(/https?:\/\/[^\s]+/g, "");
      } else if (cleanType === "whitespace") {
        result = result.replace(/\s+/g, " ").trim();
      } else if (cleanType === "diacritics") {
        result = result.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      } else if (cleanType === "nonascii") {
        result = result.replace(/[^\x00-\x7F]/g, "");
      }

      if (!preserveSpaces) {
        result = result.replace(/\s/g, "");
      }

      if (fontStyle !== "none") {
        result = applyFontStyle(result, fontStyle);
      }

      return result;
    }
    case "sentence-case": {
      const fontStyle = customSettings.fontStyle || "none";
      const caseType = customSettings.caseType || "sentence";

      let result = workingText;

      if (caseType === "sentence") {
        result = result
          .toLowerCase()
          .replace(/(^\s*\w|[.!?]\s*\w)/g, (c) => c.toUpperCase());
      } else if (caseType === "title") {
        result = result.toLowerCase().replace(/\b\w/g, (c) => c.toUpperCase());
      } else if (caseType === "lower") {
        result = result.toLowerCase();
      } else if (caseType === "upper") {
        result = result.toUpperCase();
      } else if (caseType === "alternating") {
        result = result
          .split("")
          .map((c, i) => (i % 2 === 0 ? c.toLowerCase() : c.toUpperCase()))
          .join("");
      } else if (caseType === "inverse") {
        result = result
          .split("")
          .map((c) =>
            c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase(),
          )
          .join("");
      } else if (caseType === "random") {
        result = result
          .split("")
          .map((c) => (Math.random() > 0.5 ? c.toUpperCase() : c.toLowerCase()))
          .join("");
      } else if (caseType === "camel") {
        result = result
          .toLowerCase()
          .replace(/[^a-zA-Z0-9]+(.)/g, (_, c) => c.toUpperCase());
      }

      if (fontStyle !== "none") {
        result = applyFontStyle(result, fontStyle);
      }

      return result;
    }
    case "character-counter": {
      const fontStyle = customSettings.fontStyle || "none";
      if (fontStyle !== "none") {
        return applyFontStyle(workingText, fontStyle);
      }
      return workingText;
    }
    case "invisible-character": {
      const fontStyle = customSettings.fontStyle || "none";
      const charType = customSettings.charType || "zwsp";
      const count = customSettings.count || 1;

      const invisibleChars: Record<string, string> = {
        zwsp: "\u200B",
        zwj: "\u200D",
        zwnj: "\u200C",
        hair: "\u200A",
        thin: "\u2009",
        sixPerEm: "\u2006",
        separator: "\u2063",
        wordJoiner: "\u2060",
      };

      const invisChar = invisibleChars[charType] || invisibleChars.zwsp;
      const padding = invisChar.repeat(count);

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (!text) return padding;
      return text.split("").join(padding);
    }
    case "reverse-text":
      return reverseText(workingText);
    case "bubble-text": {
      const bubbleType = customSettings.type || "out";
      const fontStyle = customSettings.fontStyle || "none";

      // Different bubble character sets
      const bubbleMaps: Record<string, Record<string, string>> = {
        out: {
          a: "â“",
          b: "â“‘",
          c: "â“’",
          d: "â““",
          e: "â“”",
          f: "â“•",
          g: "â“–",
          h: "â“—",
          i: "â“˜",
          j: "â“™",
          k: "â“š",
          l: "â“›",
          m: "â“œ",
          n: "â“",
          o: "â“",
          p: "â“Ÿ",
          q: "â“ ",
          r: "â“¡",
          s: "â“¢",
          t: "â“£",
          u: "â“¤",
          v: "â“¥",
          w: "â“¦",
          x: "â“§",
          y: "â“¨",
          z: "â“©",
          A: "â’¶",
          B: "â’·",
          C: "â’¸",
          D: "â’¹",
          E: "â’º",
          F: "â’»",
          G: "â’¼",
          H: "â’½",
          I: "â’¾",
          J: "â’¿",
          K: "â“€",
          L: "â“",
          M: "â“‚",
          N: "â“ƒ",
          O: "â“„",
          P: "â“…",
          Q: "â“†",
          R: "â“‡",
          S: "â“ˆ",
          T: "â“‰",
          U: "â“Š",
          V: "â“‹",
          W: "â“Œ",
          X: "â“",
          Y: "â“",
          Z: "â“",
          "0": "â“ª",
          "1": "â‘ ",
          "2": "â‘¡",
          "3": "â‘¢",
          "4": "â‘£",
          "5": "â‘¤",
          "6": "â‘¥",
          "7": "â‘¦",
          "8": "â‘§",
          "9": "â‘¨",
        },
        fill: {
          a: "ğŸ…",
          b: "ğŸ…‘",
          c: "ğŸ…’",
          d: "ğŸ…“",
          e: "ğŸ…”",
          f: "ğŸ…•",
          g: "ğŸ…–",
          h: "ğŸ…—",
          i: "ğŸ…˜",
          j: "ğŸ…™",
          k: "ğŸ…š",
          l: "ğŸ…›",
          m: "ğŸ…œ",
          n: "ğŸ…",
          o: "ğŸ…",
          p: "ğŸ…Ÿ",
          q: "ğŸ… ",
          r: "ğŸ…¡",
          s: "ğŸ…¢",
          t: "ğŸ…£",
          u: "ğŸ…¤",
          v: "ğŸ…¥",
          w: "ğŸ…¦",
          x: "ğŸ…§",
          y: "ğŸ…¨",
          z: "ğŸ…©",
          A: "ğŸ…",
          B: "ğŸ…‘",
          C: "ğŸ…’",
          D: "ğŸ…“",
          E: "ğŸ…”",
          F: "ğŸ…•",
          G: "ğŸ…–",
          H: "ğŸ…—",
          I: "ğŸ…˜",
          J: "ğŸ…™",
          K: "ğŸ…š",
          L: "ğŸ…›",
          M: "ğŸ…œ",
          N: "ğŸ…",
          O: "ğŸ…",
          P: "ğŸ…Ÿ",
          Q: "ğŸ… ",
          R: "ğŸ…¡",
          S: "ğŸ…¢",
          T: "ğŸ…£",
          U: "ğŸ…¤",
          V: "ğŸ…¥",
          W: "ğŸ…¦",
          X: "ğŸ…§",
          Y: "ğŸ…¨",
          Z: "ğŸ…©",
          "0": "â“¿",
          "1": "â¶",
          "2": "â·",
          "3": "â¸",
          "4": "â¹",
          "5": "âº",
          "6": "â»",
          "7": "â¼",
          "8": "â½",
          "9": "â¾",
        },
        "3d": {
          a: "ğŸ„°",
          b: "ğŸ„±",
          c: "ğŸ„²",
          d: "ğŸ„³",
          e: "ğŸ„´",
          f: "ğŸ„µ",
          g: "ğŸ„¶",
          h: "ğŸ„·",
          i: "ğŸ„¸",
          j: "ğŸ„¹",
          k: "ğŸ„º",
          l: "ğŸ„»",
          m: "ğŸ„¼",
          n: "ğŸ„½",
          o: "ğŸ„¾",
          p: "ğŸ„¿",
          q: "ğŸ…€",
          r: "ğŸ…",
          s: "ğŸ…‚",
          t: "ğŸ…ƒ",
          u: "ğŸ…„",
          v: "ğŸ……",
          w: "ğŸ…†",
          x: "ğŸ…‡",
          y: "ğŸ…ˆ",
          z: "ğŸ…‰",
          A: "ğŸ„°",
          B: "ğŸ„±",
          C: "ğŸ„²",
          D: "ğŸ„³",
          E: "ğŸ„´",
          F: "ğŸ„µ",
          G: "ğŸ„¶",
          H: "ğŸ„·",
          I: "ğŸ„¸",
          J: "ğŸ„¹",
          K: "ğŸ„º",
          L: "ğŸ„»",
          M: "ğŸ„¼",
          N: "ğŸ„½",
          O: "ğŸ„¾",
          P: "ğŸ„¿",
          Q: "ğŸ…€",
          R: "ğŸ…",
          S: "ğŸ…‚",
          T: "ğŸ…ƒ",
          U: "ğŸ…„",
          V: "ğŸ……",
          W: "ğŸ…†",
          X: "ğŸ…‡",
          Y: "ğŸ…ˆ",
          Z: "ğŸ…‰",
          "0": "0ï¸âƒ£",
          "1": "1ï¸âƒ£",
          "2": "2ï¸âƒ£",
          "3": "3ï¸âƒ£",
          "4": "4ï¸âƒ£",
          "5": "5ï¸âƒ£",
          "6": "6ï¸âƒ£",
          "7": "7ï¸âƒ£",
          "8": "8ï¸âƒ£",
          "9": "9ï¸âƒ£",
        },
        filledSquare: {
          a: "ğŸ…°",
          b: "ğŸ…±",
          c: "ğŸ…²",
          d: "ğŸ…³",
          e: "ğŸ…´",
          f: "ğŸ…µ",
          g: "ğŸ…¶",
          h: "ğŸ…·",
          i: "ğŸ…¸",
          j: "ğŸ…¹",
          k: "ğŸ…º",
          l: "ğŸ…»",
          m: "ğŸ…¼",
          n: "ğŸ…½",
          o: "ğŸ…¾",
          p: "ğŸ…¿",
          q: "ğŸ†€",
          r: "ğŸ†",
          s: "ğŸ†‚",
          t: "ğŸ†ƒ",
          u: "ğŸ†„",
          v: "ğŸ†…",
          w: "ğŸ††",
          x: "ğŸ†‡",
          y: "ğŸ†ˆ",
          z: "ğŸ†‰",
          A: "ğŸ…°",
          B: "ğŸ…±",
          C: "ğŸ…²",
          D: "ğŸ…³",
          E: "ğŸ…´",
          F: "ğŸ…µ",
          G: "ğŸ…¶",
          H: "ğŸ…·",
          I: "ğŸ…¸",
          J: "ğŸ…¹",
          K: "ğŸ…º",
          L: "ğŸ…»",
          M: "ğŸ…¼",
          N: "ğŸ…½",
          O: "ğŸ…¾",
          P: "ğŸ…¿",
          Q: "ğŸ†€",
          R: "ğŸ†",
          S: "ğŸ†‚",
          T: "ğŸ†ƒ",
          U: "ğŸ†„",
          V: "ğŸ†…",
          W: "ğŸ††",
          X: "ğŸ†‡",
          Y: "ğŸ†ˆ",
          Z: "ğŸ†‰",
        },
        parenthesized: {
          a: "â’œ",
          b: "â’",
          c: "â’",
          d: "â’Ÿ",
          e: "â’ ",
          f: "â’¡",
          g: "â’¢",
          h: "â’£",
          i: "â’¤",
          j: "â’¥",
          k: "â’¦",
          l: "â’§",
          m: "â’¨",
          n: "â’©",
          o: "â’ª",
          p: "â’«",
          q: "â’¬",
          r: "â’­",
          s: "â’®",
          t: "â’¯",
          u: "â’°",
          v: "â’±",
          w: "â’²",
          x: "â’³",
          y: "â’´",
          z: "â’µ",
          A: "â’œ",
          B: "â’",
          C: "â’",
          D: "â’Ÿ",
          E: "â’ ",
          F: "â’¡",
          G: "â’¢",
          H: "â’£",
          I: "â’¤",
          J: "â’¥",
          K: "â’¦",
          L: "â’§",
          M: "â’¨",
          N: "â’©",
          O: "â’ª",
          P: "â’«",
          Q: "â’¬",
          R: "â’­",
          S: "â’®",
          T: "â’¯",
          U: "â’°",
          V: "â’±",
          W: "â’²",
          X: "â’³",
          Y: "â’´",
          Z: "â’µ",
          "1": "â‘´",
          "2": "â‘µ",
          "3": "â‘¶",
          "4": "â‘·",
          "5": "â‘¸",
          "6": "â‘¹",
          "7": "â‘º",
          "8": "â‘»",
          "9": "â‘¼",
        },
      };

      // For bracket/corner types, wrap each character
      if (bubbleType === "bracket") {
        const base =
          fontStyle !== "none"
            ? applyFontStyle(workingText, fontStyle)
            : workingText;
        return [...base]
          .map((c) => (c === " " ? " " : "ã€" + c + "ã€‘"))
          .join("");
      }
      if (bubbleType === "corner") {
        const base =
          fontStyle !== "none"
            ? applyFontStyle(workingText, fontStyle)
            : workingText;
        return [...base]
          .map((c) => (c === " " ? " " : "ã€" + c + "ã€"))
          .join("");
      }
      if (bubbleType === "negativeCircle") {
        // Use the filled circle map (same as fill)
        const selectedMap = bubbleMaps.fill;
        return workingText
          .split("")
          .map((c) => selectedMap[c] || c)
          .join("");
      }

      const selectedMap = bubbleMaps[bubbleType] || bubbleMaps.out;
      return workingText
        .split("")
        .map((c) => selectedMap[c] || c)
        .join("");
    }
    case "wide-text": {
      const fontStyle = customSettings.fontStyle || "fullwidth";
      const widthVal = customSettings.width || 1;
      const useFullwidth = customSettings.fullwidth !== false;
      const wideSpace = " ".repeat(widthVal);

      if (fontStyle === "fullwidth" && useFullwidth) {
        return workingText
          .split("")
          .map((c) => {
            const code = c.charCodeAt(0);
            return code >= 33 && code <= 126
              ? String.fromCharCode(code + 0xfee0)
              : c;
          })
          .join(wideSpace);
      } else if (fontStyle !== "fullwidth") {
        return applyFontStyle(workingText, fontStyle).split("").join(wideSpace);
      } else {
        return workingText.split("").join(wideSpace);
      }
    }
    case "vaporwave-text": {
      const fontStyle = customSettings.fontStyle || "fullwidth";
      const widthVal = customSettings.width || 1;
      const usePalette = customSettings.palette !== false;
      const wideSpace = " ".repeat(widthVal);

      let result: string;
      if (fontStyle === "fullwidth") {
        result = workingText
          .split("")
          .map((c) => {
            const code = c.charCodeAt(0);
            return code >= 33 && code <= 126
              ? String.fromCharCode(code + 0xfee0)
              : c;
          })
          .join(wideSpace);
      } else {
        result = applyFontStyle(workingText, fontStyle)
          .split("")
          .join(wideSpace);
      }

      if (usePalette) {
        const wrapPairs = [
          ["â˜† ", " â˜†"],
          ["â˜… ", " â˜…"],
          ["âœ§ ", " âœ§"],
          ["âœ¦ ", " âœ¦"],
          ["â™¡ ", " â™¡"],
          ["â˜¯ ", " â˜¯"],
          ["âœ¿ ", " âœ¿"],
          ["â€ ", " â€"],
          ["â˜†å½¡ ", " å½¡â˜†"],
          ["âœ§Ëšâ‚Š ", " â‚ŠËšâœ§"],
          ["âŠ¹â‚Š ", " â‚ŠâŠ¹"],
        ];
        const wrap = wrapPairs[Math.floor(Math.random() * wrapPairs.length)];
        result = wrap[0] + result + wrap[1];
      }

      return result;
    }
    case "aesthetic-text": {
      const fontStyle = customSettings.fontStyle || "fullwidth";
      const widthVal = customSettings.width || 1;
      const aestheticStyle = customSettings.aestheticStyle || "vaporwave";
      const wideSpace = " ".repeat(widthVal);

      let result: string;
      if (fontStyle === "fullwidth") {
        result = workingText
          .split("")
          .map((c) => {
            const code = c.charCodeAt(0);
            return code >= 33 && code <= 126
              ? String.fromCharCode(code + 0xfee0)
              : c;
          })
          .join(wideSpace);
      } else {
        result = applyFontStyle(workingText, fontStyle)
          .split("")
          .join(wideSpace);
      }

      const styleWraps: Record<string, [string, string]> = {
        vaporwave: ["â˜†å½¡ ", " å½¡â˜†"],
        soft: ["âœ¿ ", " âœ¿"],
        grunge: ["Ã— ", " Ã—"],
        celestial: ["â˜†.ã€‚.:* ", " *:.ã€‚.â˜†"],
        cottagecore: ["ğŸŒ¿ ", " ğŸŒ¿"],
        y2k: ["âœ°â‹† ", " â‹†âœ°"],
        kawaii: ["â™¡Ëšâ‚Š ", " â‚ŠËšâ™¡"],
        cyberpunk: ["âŸ¨âŒˆ ", " âŒ‰âŸ©"],
        witchy: ["â˜½â›¤ ", " â›¤â˜½"],
        minimal: ["", ""],
      };

      const wrap = styleWraps[aestheticStyle] || styleWraps.vaporwave;
      result = wrap[0] + result + wrap[1];

      return result;
    }

    // Dark & Horror - Extra tools
    case "extra-thicc-text": {
      const thiccStyle = customSettings.thiccStyle || "serifBold";
      const letterSpacing = customSettings.spacing || 1;

      // Use applyFontStyle for all thicc styles
      let result = applyFontStyle(workingText, thiccStyle);

      // Apply letter spacing
      if (letterSpacing > 0) {
        result = result.split("").join(" ".repeat(letterSpacing));
      }
      return result;
    }
    case "glitter-text": {
      const glitterStyle = customSettings.glitterStyle || "sparkle";
      const fontStyle = customSettings.fontStyle || "serifBold";
      const glitterIntensity = customSettings.intensity || 2;

      const glitterSymbols: Record<string, string[]> = {
        sparkle: ["âœ¨", "âœ§", "â‹†", "Ëš", "âœ¦"],
        stars: ["â­", "â˜…", "â˜†", "âœª", "âœ¯"],
        diamonds: ["ğŸ’", "â—‡", "â—†", "â™¦", "âœ§"],
        rainbow: ["ğŸŒˆ", "âœ¨", "ğŸ’«", "â­", "ğŸŒŸ"],
        moonGlow: ["ğŸŒ™", "â˜½", "âœ¦", "Ëš", "â‹†"],
        sunBurst: ["â˜€", "âœ§", "âš¡", "â˜…", "âœ¦"],
        cosmicDust: ["ğŸŒŒ", "âœ¨", "â‹†", "Ëš", "âœ§"],
        firefly: ["âœ¦", "Ëš", "â‹†", "âœ§", "Â·"],
        aurora: ["ğŸŒŒ", "ğŸŒˆ", "âœ¨", "ğŸ’«", "â‹†"],
        neonGlow: ["âš¡", "âœ§", "â˜…", "âœ¦", "â‹†"],
        crystalShimmer: ["ğŸ’", "âœ§", "â‹†", "Ëš", "âœ¦"],
        goldDust: ["âœ¦", "â­", "âœ§", "â˜…", "Ëš"],
        silverMoon: ["â˜†", "âœ§", "â‹†", "Ëš", "â˜½"],
        pixieDust: ["âœ¨", "Ëš", "âœ§", "â‹†", "â˜…"],
        unicorn: ["ğŸ¦„", "âœ¨", "ğŸŒˆ", "â­", "ğŸ’«"],
        galaxy: ["ğŸŒŒ", "â­", "âœ¨", "ğŸ’«", "â˜†"],
        ocean: ["ğŸŒŠ", "âœ§", "â‹†", "Ëš", "ğŸš"],
        snowflake: ["â„", "âœ§", "â‹†", "Ëš", "â…"],
        cherry: ["ğŸŒ¸", "âœ§", "â‹†", "Ëš", "â€"],
        lightning: ["âš¡", "âœ§", "â‹†", "âœ¦", "â˜…"],
      };

      // Apply font style first
      let styledText = applyFontStyle(workingText, fontStyle);

      const symbols = glitterSymbols[glitterStyle] || glitterSymbols.sparkle;
      const insertFreq = Math.max(6 - glitterIntensity, 1);

      return styledText
        .split("")
        .map((c, i) => {
          if (c === " ") return c;
          if (i % insertFreq === 0) {
            return c + symbols[Math.floor(Math.random() * symbols.length)];
          }
          return c;
        })
        .join("");
    }
    case "square-text": {
      const squareStyle = customSettings.squareStyle || "outlined";

      // Map square styles to appropriate implementations
      switch (squareStyle) {
        case "filled":
          return mapChars(workingText, UNICODE_MAPS.invertedSquared || {});
        case "negative":
          return mapChars(workingText, UNICODE_MAPS.squared || {});
        case "circled":
          return mapChars(workingText, UNICODE_MAPS.circled || {});
        case "negativeCircle":
          return applyFontStyle(workingText, "negativeCircle");
        case "boxBrackets":
          return applyFontStyle(workingText, "boxed");
        case "lenticular":
          return applyFontStyle(workingText, "lenticular");
        case "fullBlock":
          return applyFontStyle(workingText, "heavyBlock");
        case "regional":
          return applyFontStyle(workingText, "regional");
        case "keycap":
          return applyFontStyle(workingText, "keycap");
        case "parenthesized":
          return workingText
            .split("")
            .map((c) => (c === " " ? c : `(${c.toUpperCase()})`))
            .join("");
        case "curlyBraces":
          return workingText
            .split("")
            .map((c) => (c === " " ? c : `{${c.toUpperCase()}}`))
            .join("");
        case "angleBrackets":
          return workingText
            .split("")
            .map((c) => (c === " " ? c : `<${c.toUpperCase()}>`))
            .join("");
        case "doubleBrackets":
          return workingText
            .split("")
            .map((c) => (c === " " ? c : `âŸ¦${c.toUpperCase()}âŸ§`))
            .join("");
        case "tortoise":
          return workingText
            .split("")
            .map((c) => (c === " " ? c : `ã€”${c.toUpperCase()}ã€•`))
            .join("");
        case "whiteCorner":
          return workingText
            .split("")
            .map((c) => (c === " " ? c : `ã€${c.toUpperCase()}ã€`))
            .join("");
        default:
          return mapChars(workingText, SQUARE_MAP);
      }
    }
    case "special-text": {
      const specialStyle = customSettings.specialStyle || "mixed";
      const density = customSettings.density || 2;

      const styleSymbols: Record<string, string[]> = {
        mixed: ["â˜…", "â™¥", "âœ¿", "â™ª", "â˜†", "âš¡", "âœ§", "â™¦"],
        sparkle: ["âœ¨", "âœ§", "â‹†", "Ëš", "âœ¦", "â˜…"],
        stars: ["â˜…", "â˜†", "âœª", "âœ¯", "â­", "âœ¦"],
        hearts: ["â™¥", "â™¡", "â¤", "ğŸ’•", "ğŸ’—", "ğŸ’–"],
        crown: ["ğŸ‘‘", "âœ¦", "âšœ", "âœ§", "â˜…"],
        weather: ["â˜€", "â˜", "ğŸŒ™", "âš¡", "â„", "ğŸŒˆ"],
        zodiac: [
          "â™ˆ",
          "â™‰",
          "â™Š",
          "â™‹",
          "â™Œ",
          "â™",
          "â™",
          "â™",
          "â™",
          "â™‘",
          "â™’",
          "â™“",
        ],
        music: ["â™ª", "â™«", "â™¬", "ğŸµ", "ğŸ¶", "ğŸ¼"],
        cards: ["â™ ", "â™£", "â™¥", "â™¦", "ğŸ‚¡", "ğŸƒ"],
        chess: ["â™”", "â™•", "â™–", "â™—", "â™˜", "â™™"],
        dice: ["âš€", "âš", "âš‚", "âšƒ", "âš„", "âš…"],
        arrows: ["â†’", "â†", "â†‘", "â†“", "â†—", "â†˜", "â†™", "â†–"],
        flowers: ["âœ¿", "â€", "â", "ğŸŒ¸", "ğŸŒº", "ğŸŒ»", "ğŸŒ¹", "ğŸŒ·"],
        ocean: ["ğŸŒŠ", "ğŸš", "ğŸ ", "ğŸŸ", "ğŸ¦", "ğŸ™"],
        space: ["ğŸŒŒ", "â­", "ğŸŒ™", "â˜„", "ğŸª", "ğŸš€"],
        food: ["ğŸ•", "ğŸ”", "ğŸŸ", "ğŸŒ®", "ğŸ©", "ğŸª"],
        animals: ["ğŸ±", "ğŸ¶", "ğŸ°", "ğŸ¦Š", "ğŸ»", "ğŸ¼"],
        tech: ["âŒ¨", "ğŸ–¥", "ğŸ’»", "ğŸ“±", "ğŸ”Œ", "ğŸ’¡"],
        fire: ["ğŸ”¥", "ğŸ’¥", "âš¡", "âœ§", "â˜…", "âœ¦"],
        ice: ["â„", "â…", "â†", "âœ§", "â‹†", "Ëš"],
        japanese: ["ã®", "ã¯", "ã‚’", "ã«", "ã§", "ãŒ"],
        runes: ["áš±", "áš¢", "áš¦", "áš¨", "áš±", "áš²", "áš·", "áš¹"],
      };

      const symbols = styleSymbols[specialStyle] || styleSymbols.mixed;
      const insertFreq = Math.max(6 - density, 1);

      // Apply bold font as base
      const transformed = mapChars(workingText, BOLD_MAP);

      return transformed
        .split("")
        .map((c, i) => {
          if (c === " ") return c;
          if (i % insertFreq === 0) {
            return c + symbols[Math.floor(Math.random() * symbols.length)];
          }
          return c;
        })
        .join("");
    }

    // Translators
    case "morse-code": {
      const separatorType = customSettings.separator || "slash";
      const sep =
        separatorType === "slash"
          ? " / "
          : separatorType === "pipe"
            ? " | "
            : "   ";

      // Split into words, convert each word, then join with separator
      return workingText
        .toUpperCase()
        .split(" ")
        .map((word) =>
          word
            .split("")
            .map((c) => MORSE_MAP[c] || c)
            .join(" "),
        )
        .join(sep);
    }
    case "binary": {
      const conversionType = customSettings.conversionType || "textToBinary";
      const bits = customSettings.bits || "8";
      const showPrefix = customSettings.prefix || false;
      const separator =
        customSettings.separator === "none"
          ? ""
          : customSettings.separator === "comma"
            ? ", "
            : customSettings.separator === "newline"
              ? "\n"
              : " ";

      // Helper functions for conversions
      const textToBinary = (text: string) => {
        const bitCount = parseInt(bits) || 8;
        const prefix = showPrefix ? "0b" : "";
        return text
          .split("")
          .map(
            (char) =>
              prefix + char.charCodeAt(0).toString(2).padStart(bitCount, "0"),
          )
          .join(separator);
      };

      const binaryToText = (binary: string) => {
        const cleanBinary = binary.replace(/0b/gi, "").replace(/[^01\s]/g, "");
        const bytes = cleanBinary.split(/\s+/).filter((b) => b);
        return bytes.map((b) => String.fromCharCode(parseInt(b, 2))).join("");
      };

      const textToHex = (text: string) => {
        const prefix = showPrefix ? "0x" : "";
        return text
          .split("")
          .map(
            (char) =>
              prefix +
              char.charCodeAt(0).toString(16).toUpperCase().padStart(2, "0"),
          )
          .join(separator);
      };

      const hexToText = (hex: string) => {
        const cleanHex = hex.replace(/0x/gi, "").replace(/[^0-9a-fA-F\s]/g, "");
        const bytes = cleanHex.match(/.{1,2}/g) || [];
        return bytes.map((b) => String.fromCharCode(parseInt(b, 16))).join("");
      };

      const textToDecimal = (text: string) => {
        return text
          .split("")
          .map((char) => char.charCodeAt(0).toString())
          .join(separator);
      };

      const decimalToText = (dec: string) => {
        const numbers = dec.split(/[\s,]+/).filter((n) => n);
        return numbers
          .map((n) => String.fromCharCode(parseInt(n, 10)))
          .join("");
      };

      const textToOctal = (text: string) => {
        const prefix = showPrefix ? "0o" : "";
        return text
          .split("")
          .map((char) => prefix + char.charCodeAt(0).toString(8))
          .join(separator);
      };

      const octalToText = (oct: string) => {
        const cleanOctal = oct.replace(/0o/gi, "").replace(/[^0-7\s]/g, "");
        const bytes = cleanOctal.split(/\s+/).filter((b) => b);
        return bytes.map((b) => String.fromCharCode(parseInt(b, 8))).join("");
      };

      const binaryToHex = (binary: string) => {
        const cleanBinary = binary.replace(/0b/gi, "").replace(/[^01\s]/g, "");
        const bytes = cleanBinary.split(/\s+/).filter((b) => b);
        const prefix = showPrefix ? "0x" : "";
        return bytes
          .map((b) => prefix + parseInt(b, 2).toString(16).toUpperCase())
          .join(separator);
      };

      const hexToBinary = (hex: string) => {
        const cleanHex = hex.replace(/0x/gi, "").replace(/[^0-9a-fA-F\s]/g, "");
        const bytes = cleanHex.match(/.{1,2}/g) || [];
        const prefix = showPrefix ? "0b" : "";
        return bytes
          .map((b) => prefix + parseInt(b, 16).toString(2).padStart(8, "0"))
          .join(separator);
      };

      const binaryToDecimal = (binary: string) => {
        const cleanBinary = binary.replace(/0b/gi, "").replace(/[^01\s]/g, "");
        const bytes = cleanBinary.split(/\s+/).filter((b) => b);
        return bytes.map((b) => parseInt(b, 2).toString()).join(separator);
      };

      const decimalToBinary = (dec: string) => {
        const numbers = dec.split(/[\s,]+/).filter((n) => n);
        const bitCount = parseInt(bits) || 8;
        const prefix = showPrefix ? "0b" : "";
        return numbers
          .map(
            (n) => prefix + parseInt(n, 10).toString(2).padStart(bitCount, "0"),
          )
          .join(separator);
      };

      const hexToDecimal = (hex: string) => {
        const cleanHex = hex.replace(/0x/gi, "").replace(/[^0-9a-fA-F\s]/g, "");
        const bytes = cleanHex.match(/.{1,2}/g) || [];
        return bytes.map((b) => parseInt(b, 16).toString()).join(separator);
      };

      const decimalToHex = (dec: string) => {
        const numbers = dec.split(/[\s,]+/).filter((n) => n);
        const prefix = showPrefix ? "0x" : "";
        return numbers
          .map((n) => prefix + parseInt(n, 10).toString(16).toUpperCase())
          .join(separator);
      };

      const octalToDecimal = (oct: string) => {
        const cleanOctal = oct.replace(/0o/gi, "").replace(/[^0-7\s]/g, "");
        const bytes = cleanOctal.split(/\s+/).filter((b) => b);
        return bytes.map((b) => parseInt(b, 8).toString()).join(separator);
      };

      const decimalToOctal = (dec: string) => {
        const numbers = dec.split(/[\s,]+/).filter((n) => n);
        const prefix = showPrefix ? "0o" : "";
        return numbers
          .map((n) => prefix + parseInt(n, 10).toString(8))
          .join(separator);
      };

      // Execute the selected conversion
      switch (conversionType) {
        case "textToBinary":
          return textToBinary(workingText);
        case "binaryToText":
          return binaryToText(workingText);
        case "textToHex":
          return textToHex(workingText);
        case "hexToText":
          return hexToText(workingText);
        case "textToDecimal":
          return textToDecimal(workingText);
        case "decimalToText":
          return decimalToText(workingText);
        case "textToOctal":
          return textToOctal(workingText);
        case "octalToText":
          return octalToText(workingText);
        case "binaryToHex":
          return binaryToHex(workingText);
        case "hexToBinary":
          return hexToBinary(workingText);
        case "binaryToDecimal":
          return binaryToDecimal(workingText);
        case "decimalToBinary":
          return decimalToBinary(workingText);
        case "hexToDecimal":
          return hexToDecimal(workingText);
        case "decimalToHex":
          return decimalToHex(workingText);
        case "octalToDecimal":
          return octalToDecimal(workingText);
        case "decimalToOctal":
          return decimalToOctal(workingText);
        default:
          return textToBinary(workingText);
      }
    }
    case "hex-code": {
      const hexMode = customSettings.mode || "encode";
      const isUpper = customSettings.uppercase !== false;
      const showPrefix = customSettings.prefix === true;
      const sep = customSettings.separator ?? " ";
      const format = customSettings.format || "raw";

      if (hexMode === "decode") {
        try {
          const cleanHex = workingText
            .replace(/0x/gi, "")
            .replace(/%/g, "")
            .replace(/\\x/gi, "")
            .replace(/&#x/gi, "")
            .replace(/;/g, "")
            .replace(/[^0-9a-fA-F\s]/g, "");
          const bytes = cleanHex.match(/.{1,2}/g) || [];
          return bytes
            .map((b) => String.fromCharCode(parseInt(b, 16)))
            .join("");
        } catch {
          return "Invalid Hex Input";
        }
      }

      return workingText
        .split("")
        .map((char) => {
          let hex = char.charCodeAt(0).toString(16);
          if (isUpper) hex = hex.toUpperCase();
          if (hex.length === 1) hex = "0" + hex;

          if (format === "cssColor") return "#" + hex;
          if (format === "htmlEntity") return "&#x" + hex + ";";
          if (format === "urlEncoded") return "%" + hex;
          if (format === "cStyle") return "\\x" + hex;
          return (showPrefix ? "0x" : "") + hex;
        })
        .join(sep);
    }
    case "base64": {
      const mode = customSettings.mode || "encode";
      const variant = customSettings.variant || "standard";
      const urlSafe = customSettings.urlSafe === true;
      const usePadding = customSettings.padding !== false;
      const lineBreaks = customSettings.lineBreaks === true;

      if (mode === "decode") {
        try {
          if (variant === "base32") {
            const base32Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
            const clean = workingText.toUpperCase().replace(/[^A-Z2-7]/g, "");
            let bits = "";
            for (const c of clean) {
              bits += base32Chars.indexOf(c).toString(2).padStart(5, "0");
            }
            let out = "";
            for (let i = 0; i + 8 <= bits.length; i += 8) {
              out += String.fromCharCode(parseInt(bits.substr(i, 8), 2));
            }
            return out;
          }
          if (variant === "urlEncode") return decodeURIComponent(workingText);
          return atob(workingText);
        } catch {
          return "Invalid Input";
        }
      }

      let result = "";
      if (variant === "base32") {
        const base32Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
        let bits = "";
        for (const c of workingText) {
          bits += c.charCodeAt(0).toString(2).padStart(8, "0");
        }
        while (bits.length % 5 !== 0) bits += "0";
        for (let i = 0; i < bits.length; i += 5) {
          result += base32Chars[parseInt(bits.substr(i, 5), 2)];
        }
        if (usePadding) {
          while (result.length % 8 !== 0) result += "=";
        }
      } else if (variant === "urlEncode") {
        result = encodeURIComponent(workingText);
      } else if (variant === "ascii85") {
        const encode85 = (data: string) => {
          let out = "<~";
          for (let i = 0; i < data.length; i += 4) {
            let val = 0;
            const chunk = data.slice(i, i + 4);
            for (let j = 0; j < 4; j++)
              val = val * 256 + (chunk.charCodeAt(j) || 0);
            if (val === 0 && chunk.length === 4) {
              out += "z";
              continue;
            }
            const chars = [];
            for (let j = 4; j >= 0; j--) {
              chars[j] = String.fromCharCode((val % 85) + 33);
              val = Math.floor(val / 85);
            }
            out += chars.join("").substring(0, chunk.length + 1);
          }
          return out + "~>";
        };
        result = encode85(workingText);
      } else {
        result = btoa(workingText);
        if (urlSafe) result = result.replace(/\+/g, "-").replace(/\//g, "_");
        if (!usePadding) result = result.replace(/=+$/, "");
      }

      if (lineBreaks && result.length > 76) {
        result = result.match(/.{1,76}/g)?.join("\n") || result;
      }
      return result;
    }
    case "reverse-text": {
      const fontStyle = customSettings.fontStyle || "none";
      const mode = customSettings.mode || "entire";

      let text =
        fontStyle !== "none"
          ? applyFontStyle(workingText, fontStyle)
          : workingText;

      if (mode === "words") {
        return text
          .split(" ")
          .map((w) => w.split("").reverse().join(""))
          .join(" ");
      } else if (mode === "vertical") {
        return mapChars(text, UPSIDE_DOWN_MAP);
      } else if (mode === "lines") {
        return text.split("\n").reverse().join("\n");
      } else if (mode === "sentences") {
        return text
          .split(/([.!?]+\s*)/)
          .reverse()
          .join("");
      }
      return text.split("").reverse().join("");
    }
    case "caesar-cipher": {
      const fontStyle = customSettings.fontStyle || "none";
      const shift = customSettings.shift || 3;
      const direction = customSettings.direction || "encode";
      const alphabet = customSettings.alphabet || "standard";

      let result = "";

      if (alphabet === "ascii") {
        const actualShift = direction === "encode" ? shift : 95 - (shift % 95);
        result = workingText
          .split("")
          .map((char) => {
            const code = char.charCodeAt(0);
            if (code >= 32 && code <= 126) {
              return String.fromCharCode(((code - 32 + actualShift) % 95) + 32);
            }
            return char;
          })
          .join("");
      } else if (alphabet === "alphanumeric") {
        const chars =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        const actualShift =
          direction === "encode"
            ? shift
            : chars.length - (shift % chars.length);
        result = workingText
          .split("")
          .map((char) => {
            const idx = chars.indexOf(char);
            if (idx >= 0) return chars[(idx + actualShift) % chars.length];
            return char;
          })
          .join("");
      } else {
        const actualShift = direction === "encode" ? shift : 26 - (shift % 26);
        result = workingText
          .split("")
          .map((char) => {
            if (char.match(/[a-z]/i)) {
              const code = char.charCodeAt(0);
              const base = code >= 97 ? 97 : 65;
              return String.fromCharCode(
                ((code - base + actualShift) % 26) + base,
              );
            }
            return char;
          })
          .join("");
      }

      if (fontStyle !== "none") result = applyFontStyle(result, fontStyle);
      return result;
    }
    case "rot13": {
      const fontStyle = customSettings.fontStyle || "none";
      const variant = customSettings.variant || "rot13";

      let result = "";

      if (variant === "rot5") {
        result = workingText
          .split("")
          .map((char) => {
            if (char.match(/[0-9]/)) {
              return String.fromCharCode(
                ((char.charCodeAt(0) - 48 + 5) % 10) + 48,
              );
            }
            return char;
          })
          .join("");
      } else if (variant === "rot18") {
        result = workingText
          .split("")
          .map((char) => {
            if (char.match(/[a-z]/i)) {
              const code = char.charCodeAt(0);
              const base = code >= 97 ? 97 : 65;
              return String.fromCharCode(((code - base + 13) % 26) + base);
            }
            if (char.match(/[0-9]/)) {
              return String.fromCharCode(
                ((char.charCodeAt(0) - 48 + 5) % 10) + 48,
              );
            }
            return char;
          })
          .join("");
      } else if (variant === "rot47") {
        result = workingText
          .split("")
          .map((char) => {
            const code = char.charCodeAt(0);
            if (code >= 33 && code <= 126) {
              return String.fromCharCode(((code - 33 + 47) % 94) + 33);
            }
            return char;
          })
          .join("");
      } else {
        result = workingText
          .split("")
          .map((char) => {
            if (char.match(/[a-z]/i)) {
              const code = char.charCodeAt(0);
              const base = code >= 97 ? 97 : 65;
              return String.fromCharCode(((code - base + 13) % 26) + base);
            }
            return char;
          })
          .join("");
      }

      if (fontStyle !== "none") result = applyFontStyle(result, fontStyle);
      return result;
    }
    case "nato-phonetic": {
      const fontStyle = customSettings.fontStyle || "none";
      const alphabetType = customSettings.alphabet || "nato";
      const showOriginal = customSettings.showOriginal === true;

      const natoAlphabets: Record<string, Record<string, string>> = {
        nato: {
          a: "Alpha",
          b: "Bravo",
          c: "Charlie",
          d: "Delta",
          e: "Echo",
          f: "Foxtrot",
          g: "Golf",
          h: "Hotel",
          i: "India",
          j: "Juliett",
          k: "Kilo",
          l: "Lima",
          m: "Mike",
          n: "November",
          o: "Oscar",
          p: "Papa",
          q: "Quebec",
          r: "Romeo",
          s: "Sierra",
          t: "Tango",
          u: "Uniform",
          v: "Victor",
          w: "Whiskey",
          x: "X-ray",
          y: "Yankee",
          z: "Zulu",
          "0": "Zero",
          "1": "One",
          "2": "Two",
          "3": "Three",
          "4": "Four",
          "5": "Five",
          "6": "Six",
          "7": "Seven",
          "8": "Eight",
          "9": "Nine",
        },
        usmilitary: {
          a: "Able",
          b: "Baker",
          c: "Charlie",
          d: "Dog",
          e: "Easy",
          f: "Fox",
          g: "George",
          h: "How",
          i: "Item",
          j: "Jig",
          k: "King",
          l: "Love",
          m: "Mike",
          n: "Nan",
          o: "Oboe",
          p: "Peter",
          q: "Queen",
          r: "Roger",
          s: "Sugar",
          t: "Tare",
          u: "Uncle",
          v: "Victor",
          w: "William",
          x: "X-ray",
          y: "Yoke",
          z: "Zebra",
          "0": "Zero",
          "1": "One",
          "2": "Two",
          "3": "Three",
          "4": "Four",
          "5": "Five",
          "6": "Six",
          "7": "Seven",
          "8": "Eight",
          "9": "Niner",
        },
        royalnavy: {
          a: "Acre",
          b: "Beer",
          c: "Charlie",
          d: "Dover",
          e: "Edward",
          f: "Fredrick",
          g: "George",
          h: "Harry",
          i: "Ink",
          j: "Johnnie",
          k: "King",
          l: "London",
          m: "Monkey",
          n: "Nuts",
          o: "Orange",
          p: "Pudding",
          q: "Queenie",
          r: "Robert",
          s: "Sugar",
          t: "Tommy",
          u: "Uncle",
          v: "Vinegar",
          w: "William",
          x: "Xerxes",
          y: "Yellow",
          z: "Zebra",
          "0": "Zero",
          "1": "One",
          "2": "Two",
          "3": "Three",
          "4": "Four",
          "5": "Five",
          "6": "Six",
          "7": "Seven",
          "8": "Eight",
          "9": "Nine",
        },
        westernunion: {
          a: "Adams",
          b: "Boston",
          c: "Chicago",
          d: "Denver",
          e: "Easy",
          f: "Frank",
          g: "George",
          h: "Henry",
          i: "Ida",
          j: "John",
          k: "King",
          l: "Lincoln",
          m: "Mary",
          n: "New York",
          o: "Ocean",
          p: "Peter",
          q: "Queen",
          r: "Roger",
          s: "Sugar",
          t: "Thomas",
          u: "Union",
          v: "Victor",
          w: "William",
          x: "X-ray",
          y: "Young",
          z: "Zero",
          "0": "Zero",
          "1": "One",
          "2": "Two",
          "3": "Three",
          "4": "Four",
          "5": "Five",
          "6": "Six",
          "7": "Seven",
          "8": "Eight",
          "9": "Nine",
        },
        german: {
          a: "Anton",
          b: "Berta",
          c: "CÃ¤sar",
          d: "Dora",
          e: "Emil",
          f: "Friedrich",
          g: "Gustav",
          h: "Heinrich",
          i: "Ida",
          j: "Julius",
          k: "Kaufmann",
          l: "Ludwig",
          m: "Martha",
          n: "Nordpol",
          o: "Otto",
          p: "Paula",
          q: "Quelle",
          r: "Richard",
          s: "Samuel",
          t: "Theodor",
          u: "Ulrich",
          v: "Viktor",
          w: "Wilhelm",
          x: "Xanthippe",
          y: "Ypsilon",
          z: "Zacharias",
          "0": "Null",
          "1": "Eins",
          "2": "Zwei",
          "3": "Drei",
          "4": "Vier",
          "5": "FÃ¼nf",
          "6": "Sechs",
          "7": "Sieben",
          "8": "Acht",
          "9": "Neun",
        },
      };

      const phoneticMap = natoAlphabets[alphabetType] || natoAlphabets.nato;
      const sep = customSettings.separator || "-";

      let result = workingText
        .toLowerCase()
        .split("")
        .map((c) => {
          const word = phoneticMap[c];
          if (word) {
            return showOriginal ? `${c.toUpperCase()}=${word}` : word;
          }
          return c;
        })
        .join(sep);

      if (fontStyle !== "none") result = applyFontStyle(result, fontStyle);
      return result;
    }
    case "atbash": {
      const fontStyle = customSettings.fontStyle || "none";
      const includeNumbers = customSettings.includeNumbers === true;

      let result = workingText
        .split("")
        .map((char) => {
          if (char.match(/[a-z]/i)) {
            const code = char.charCodeAt(0);
            if (code >= 97 && code <= 122)
              return String.fromCharCode(122 - (code - 97));
            if (code >= 65 && code <= 90)
              return String.fromCharCode(90 - (code - 65));
          }
          if (includeNumbers && char.match(/[0-9]/)) {
            return String.fromCharCode(57 - (char.charCodeAt(0) - 48));
          }
          return char;
        })
        .join("");

      if (fontStyle !== "none") result = applyFontStyle(result, fontStyle);
      return result;
    }
    case "leetspeak": {
      const fontStyle = customSettings.fontStyle || "none";
      const level = customSettings.level || "basic";
      const capsMode = customSettings.capsMode || "lower";

      const basic: Record<string, string> = {
        a: "4",
        e: "3",
        i: "1",
        o: "0",
        s: "5",
        t: "7",
      };
      const advanced: Record<string, string> = {
        ...basic,
        b: "8",
        g: "9",
        l: "1",
        z: "2",
      };
      const elite: Record<string, string> = {
        ...advanced,
        a: "@",
        c: "(",
        d: "|)",
        f: "ph",
        h: "|-|",
        k: "|<",
        m: "\\/\\/|",
        n: "|\\|",
        r: "|2",
        u: "|_|",
        v: "\\/",
        w: "\\/\\/",
      };
      const ultra: Record<string, string> = {
        ...elite,
        a: "/-\\",
        b: "!3",
        c: "[",
        d: "cl",
        e: "[-",
        g: "C-",
        h: "]-[",
        i: "][",
        j: ",_|",
        k: "|{",
        l: "|_",
        m: "|V|",
        n: "/\\/",
        o: "()",
        p: "|*",
        q: "(_,)",
        r: "|?",
        s: "$",
        t: "+",
        u: "(_)",
        v: "\\/",
        w: "\\_|_/",
        x: "}{",
        y: "`/",
        z: "2",
      };

      let map: Record<string, string>;
      if (level === "random") {
        const maps = [basic, advanced, elite, ultra];
        map = {};
        "abcdefghijklmnopqrstuvwxyz".split("").forEach((c) => {
          const randomMap = maps[Math.floor(Math.random() * maps.length)];
          map[c] = randomMap[c] || c;
        });
      } else {
        map =
          level === "ultra"
            ? ultra
            : level === "elite"
              ? elite
              : level === "advanced"
                ? advanced
                : basic;
      }

      let text = workingText.toLowerCase();
      let result = text
        .split("")
        .map((c) => map[c] || c)
        .join("");

      if (capsMode === "upper") result = result.toUpperCase();
      else if (capsMode === "alternating")
        result = result
          .split("")
          .map((c, i) => (i % 2 === 0 ? c : c.toUpperCase()))
          .join("");
      else if (capsMode === "random")
        result = result
          .split("")
          .map((c) => (Math.random() > 0.5 ? c.toUpperCase() : c))
          .join("");

      if (fontStyle !== "none") result = applyFontStyle(result, fontStyle);
      return result;
    }
    case "wingdings": {
      const style = customSettings.style || "classic";
      const addSpacing = customSettings.spacing === true;

      // Different wingdings character sets - 15 styles
      const wingdingsSets: Record<string, Record<string, string>> = {
        classic: {
          a: "âœŒ",
          b: "ğŸ‘Œ",
          c: "ğŸ‘",
          d: "ğŸ‘",
          e: "ğŸ‘ˆ",
          f: "ğŸ‘‰",
          g: "ğŸ‘†",
          h: "ğŸ‘‡",
          i: "âœ‹",
          j: "â˜º",
          k: "ğŸ˜",
          l: "â˜¹",
          m: "ğŸ’£",
          n: "â˜ ",
          o: "âš",
          p: "âš‘",
          q: "âœ‰",
          r: "âœ‚",
          s: "âœ",
          t: "ğŸ‘“",
          u: "âŒ›",
          v: "âŒ¨",
          w: "ğŸ–±",
          x: "ğŸ–¨",
          y: "ğŸ“",
          z: "ğŸ“‚",
        },
        webdings: {
          a: "ğŸ•·",
          b: "ğŸ•¸",
          c: "ğŸ ",
          d: "ğŸš—",
          e: "âœˆ",
          f: "â˜",
          g: "ğŸŒ§",
          h: "â›ˆ",
          i: "â„",
          j: "â˜€",
          k: "ğŸŒ™",
          l: "â­",
          m: "ğŸ”¥",
          n: "ğŸ’§",
          o: "ğŸŒŠ",
          p: "ğŸŒ²",
          q: "ğŸŒ¸",
          r: "ğŸ€",
          s: "ğŸ‚",
          t: "ğŸ¦",
          u: "ğŸŸ",
          v: "ğŸ•",
          w: "ğŸˆ",
          x: "ğŸ¦‹",
          y: "ğŸ",
          z: "ğŸ",
        },
        symbols: {
          a: "â™ ",
          b: "â™£",
          c: "â™¥",
          d: "â™¦",
          e: "â˜…",
          f: "â˜†",
          g: "â—",
          h: "â—‹",
          i: "â– ",
          j: "â–¡",
          k: "â–²",
          l: "â–³",
          m: "â—†",
          n: "â—‡",
          o: "â¬Ÿ",
          p: "â¬ ",
          q: "âœ¦",
          r: "âœ§",
          s: "â–",
          t: "âœš",
          u: "âœ›",
          v: "âœœ",
          w: "âœ¢",
          x: "âœ£",
          y: "âœ¤",
          z: "âœ¥",
        },
        wingdings2: {
          a: "âœ°",
          b: "âœ±",
          c: "âœ²",
          d: "âœ³",
          e: "âœ´",
          f: "âœµ",
          g: "âœ¶",
          h: "âœ·",
          i: "âœ¸",
          j: "âœ¹",
          k: "âœº",
          l: "âœ»",
          m: "âœ¼",
          n: "âœ½",
          o: "âœ¾",
          p: "âœ¿",
          q: "â€",
          r: "â",
          s: "â‚",
          t: "âƒ",
          u: "â„",
          v: "â…",
          w: "â†",
          x: "â‡",
          y: "âˆ",
          z: "â‰",
        },
        wingdings3: {
          a: "â€",
          b: "â",
          c: "â‚",
          d: "âƒ",
          e: "â„",
          f: "â…",
          g: "â†",
          h: "â‡",
          i: "âˆ",
          j: "â‰",
          k: "âŠ",
          l: "â‹",
          m: "âŒ",
          n: "â",
          o: "â",
          p: "â",
          q: "â",
          r: "â‘",
          s: "â’",
          t: "â“",
          u: "â“µ",
          v: "â“¶",
          w: "â“·",
          x: "â“¸",
          y: "â“¹",
          z: "â“º",
        },
        zodiac: {
          a: "â™ˆ",
          b: "â™‰",
          c: "â™Š",
          d: "â™‹",
          e: "â™Œ",
          f: "â™",
          g: "â™",
          h: "â™",
          i: "â™",
          j: "â™‘",
          k: "â™’",
          l: "â™“",
          m: "â˜‰",
          n: "â˜½",
          o: "â˜¿",
          p: "â™€",
          q: "â™‚",
          r: "â™ƒ",
          s: "â™„",
          t: "â™…",
          u: "â™†",
          v: "â™‡",
          w: "âš³",
          x: "âš´",
          y: "âšµ",
          z: "âš¶",
        },
        arrows: {
          a: "â†’",
          b: "â†",
          c: "â†‘",
          d: "â†“",
          e: "â†”",
          f: "â†•",
          g: "â†–",
          h: "â†—",
          i: "â†˜",
          j: "â†™",
          k: "â‡",
          l: "â‡’",
          m: "â‡‘",
          n: "â‡“",
          o: "â‡”",
          p: "â‡•",
          q: "âœ",
          r: "â",
          s: "â",
          t: "âŸ",
          u: "â ",
          v: "â¡",
          w: "â¢",
          x: "â£",
          y: "â¤",
          z: "â¥",
        },
        geometric: {
          a: "â—‰",
          b: "â—Š",
          c: "â—‹",
          d: "â—Œ",
          e: "â—",
          f: "â—",
          g: "â—",
          h: "â—",
          i: "â—‘",
          j: "â—’",
          k: "â—“",
          l: "â—”",
          m: "â—•",
          n: "â—–",
          o: "â——",
          p: "â—˜",
          q: "â—™",
          r: "â—š",
          s: "â—›",
          t: "â—œ",
          u: "â—",
          v: "â—",
          w: "â—Ÿ",
          x: "â— ",
          y: "â—¡",
          z: "â—¢",
        },
        music: {
          a: "â™©",
          b: "â™ª",
          c: "â™«",
          d: "â™¬",
          e: "â™­",
          f: "â™®",
          g: "â™¯",
          h: "ğ„",
          i: "ğ„¢",
          j: "ğ„«",
          k: "ğ„ª",
          l: "ğ„",
          m: "ğ„‘",
          n: "ğ„’",
          o: "ğ„“",
          p: "ğ„”",
          q: "ğ„•",
          r: "ğ„–",
          s: "ğ„—",
          t: "ğ„˜",
          u: "ğ„™",
          v: "ğ„š",
          w: "ğ„›",
          x: "ğ„œ",
          y: "ğ„",
          z: "ğ„°",
        },
        weather: {
          a: "â˜€",
          b: "â˜",
          c: "â˜‚",
          d: "â˜ƒ",
          e: "â˜„",
          f: "â˜…",
          g: "â˜†",
          h: "â˜‡",
          i: "â˜ˆ",
          j: "â˜‰",
          k: "â˜Š",
          l: "â˜‹",
          m: "â˜Œ",
          n: "â˜",
          o: "â›…",
          p: "â›†",
          q: "â›‡",
          r: "â›ˆ",
          s: "â„",
          t: "â…",
          u: "â†",
          v: "â›„",
          w: "ğŸŒˆ",
          x: "âš¡",
          y: "ğŸŒ§",
          z: "ğŸŒ©",
        },
        tech: {
          a: "âŒ˜",
          b: "âŒ¥",
          c: "â‡§",
          d: "âŒƒ",
          e: "â‹",
          f: "â",
          g: "âŒ«",
          h: "â‡¥",
          i: "âŒ§",
          j: "â",
          k: "â—",
          l: "â˜",
          m: "âŒ¨",
          n: "ğŸ–¥",
          o: "ğŸ–¨",
          p: "ğŸ–±",
          q: "ğŸ’¾",
          r: "ğŸ’¿",
          s: "ğŸ“€",
          t: "ğŸ”Œ",
          u: "ğŸ“¡",
          v: "ğŸ“¶",
          w: "ğŸ”‹",
          x: "âš™",
          y: "ğŸ”§",
          z: "ğŸ”¨",
        },
        religious: {
          a: "âœ",
          b: "â˜¦",
          c: "âœ¡",
          d: "â˜ª",
          e: "â˜¯",
          f: "â˜¸",
          g: "âœ ",
          h: "âœ™",
          i: "âœš",
          j: "âœ›",
          k: "âœœ",
          l: "âœ",
          m: "âœŸ",
          n: "â€ ",
          o: "â€¡",
          p: "â˜¥",
          q: "âš•",
          r: "â˜¬",
          s: "â˜­",
          t: "â˜®",
          u: "â˜¯",
          v: "å",
          w: "å",
          x: "à¥",
          y: "â˜©",
          z: "â˜¨",
        },
        cards: {
          a: "â™ ",
          b: "â™¤",
          c: "â™¥",
          d: "â™¡",
          e: "â™¦",
          f: "â™¢",
          g: "â™£",
          h: "â™§",
          i: "ğŸ‚ ",
          j: "ğŸ‚¡",
          k: "ğŸ‚¢",
          l: "ğŸ‚£",
          m: "ğŸ‚¤",
          n: "ğŸ‚¥",
          o: "ğŸ‚¦",
          p: "ğŸ‚§",
          q: "ğŸ‚¨",
          r: "ğŸ‚©",
          s: "ğŸ‚ª",
          t: "ğŸ‚«",
          u: "ğŸ‚¬",
          v: "ğŸ‚­",
          w: "ğŸ‚®",
          x: "ğŸƒ",
          y: "ğŸ´",
          z: "ğŸ€„",
        },
        dingbats: {
          a: "â§",
          b: "â˜™",
          c: "â¦",
          d: "â¡",
          e: "â¢",
          f: "â£",
          g: "â¤",
          h: "â¥",
          i: "â©",
          j: "âª",
          k: "â«",
          l: "â¬",
          m: "â­",
          n: "â®",
          o: "â¯",
          p: "â°",
          q: "â±",
          r: "â²",
          s: "â³",
          t: "â´",
          u: "âµ",
          v: "â‚",
          w: "â•",
          x: "â–",
          y: "â˜",
          z: "â™",
        },
        mathematical: {
          a: "Â±",
          b: "Ã—",
          c: "Ã·",
          d: "â‰ ",
          e: "â‰¤",
          f: "â‰¥",
          g: "âˆ",
          h: "âˆ‘",
          i: "âˆ",
          j: "âˆš",
          k: "âˆ›",
          l: "âˆœ",
          m: "âˆ«",
          n: "âˆ¬",
          o: "âˆ­",
          p: "Ï€",
          q: "Î©",
          r: "âˆ‚",
          s: "âˆ‡",
          t: "âˆˆ",
          u: "âˆ‰",
          v: "âˆ‹",
          w: "âˆŒ",
          x: "âŠ‚",
          y: "âŠƒ",
          z: "âŠ†",
        },
      };

      const charMap = wingdingsSets[style] || wingdingsSets.classic;
      const separator = addSpacing ? " " : "";

      return workingText
        .toLowerCase()
        .split("")
        .map((c) => {
          return charMap[c] || c;
        })
        .join(separator);
    }
    case "runic": {
      const alphabet = customSettings.alphabet || "elder";
      const medieval = customSettings.medieval === true;
      const showRuneNames = customSettings.showRuneNames === true;
      const showPoemExcerpt = customSettings.showPoemExcerpt === true;

      // Extended runic sets - 10 different alphabets
      const runicSets: Record<string, Record<string, string>> = {
        elder: {
          a: "áš¨",
          b: "á›’",
          c: "áš²",
          d: "á›",
          e: "á›–",
          f: "áš ",
          g: "áš·",
          h: "ášº",
          i: "á›",
          j: "á›ƒ",
          k: "áš²",
          l: "á›š",
          m: "á›—",
          n: "áš¾",
          o: "á›Ÿ",
          p: "á›ˆ",
          q: "áš²",
          r: "áš±",
          s: "á›Š",
          t: "á›",
          u: "áš¢",
          v: "áš¹",
          w: "áš¹",
          x: "áš²á›Š",
          y: "á›‡",
          z: "á›‰",
        },
        younger: {
          a: "á›…",
          b: "á›’",
          c: "áš´",
          d: "á›",
          e: "á›",
          f: "áš ",
          g: "áš´",
          h: "áš¼",
          i: "á›",
          j: "á›",
          k: "áš´",
          l: "á›š",
          m: "á›˜",
          n: "áš¾",
          o: "áš¢",
          p: "á›’",
          q: "áš´",
          r: "áš±",
          s: "á›‹",
          t: "á›",
          u: "áš¢",
          v: "áš¢",
          w: "áš¢",
          x: "áš´á›‹",
          y: "áš¤",
          z: "á›‹",
        },
        anglosaxon: {
          a: "ášª",
          b: "á›’",
          c: "áš³",
          d: "á›",
          e: "á›–",
          f: "áš ",
          g: "áš·",
          h: "áš»",
          i: "á›",
          j: "á›¡",
          k: "áš³",
          l: "á›š",
          m: "á›—",
          n: "áš¾",
          o: "áš©",
          p: "á›ˆ",
          q: "áš³áš¹",
          r: "áš±",
          s: "á›‹",
          t: "á›",
          u: "áš¢",
          v: "áš¹",
          w: "áš¹",
          x: "áš³á›‹",
          y: "áš£",
          z: "á›‰",
        },
        medieval: {
          a: "á›†",
          b: "á›’",
          c: "á›",
          d: "á›‘",
          e: "á›‚",
          f: "áš ",
          g: "ášµ",
          h: "áš¼",
          i: "á›",
          j: "á›",
          k: "áš´",
          l: "á›š",
          m: "á›˜",
          n: "áš¿",
          o: "áš®",
          p: "á›”",
          q: "áš´",
          r: "áš±",
          s: "á›Œ",
          t: "á›",
          u: "áš¢",
          v: "áš¡",
          w: "áš¢",
          x: "á›Œ",
          y: "á›¦",
          z: "á›Œ",
        },
        dalecarlian: {
          a: "ğŒ€",
          b: "ğŒ",
          c: "ğŒ‚",
          d: "ğŒƒ",
          e: "ğŒ„",
          f: "ğŒ…",
          g: "ğŒ†",
          h: "ğŒ‡",
          i: "ğŒ‰",
          j: "ğŒ‰",
          k: "ğŒŠ",
          l: "ğŒ‹",
          m: "ğŒŒ",
          n: "ğŒ",
          o: "ğŒ",
          p: "ğŒ",
          q: "ğŒ’",
          r: "ğŒ“",
          s: "ğŒ”",
          t: "ğŒ•",
          u: "ğŒ–",
          v: "ğŒ–",
          w: "ğŒ–",
          x: "ğŒ—",
          y: "ğŒ–",
          z: "ğŒ†",
        },
        marcomannic: {
          a: "áš«",
          b: "á›”",
          c: "á›¤",
          d: "á›¥",
          e: "á›¯",
          f: "áš¨",
          g: "ášµ",
          h: "ášº",
          i: "á›ƒ",
          j: "á›ƒ",
          k: "á›¤",
          l: "áš»",
          m: "á›—",
          n: "áš¿",
          o: "á›¨",
          p: "á›ˆ",
          q: "á›¤",
          r: "á›•",
          s: "á›§",
          t: "á›¦",
          u: "áš©",
          v: "áš¦",
          w: "áš¦",
          x: "á›¤á›‹",
          y: "á›£",
          z: "á›°",
        },
        gothic: {
          a: "ğŒ°",
          b: "ğŒ±",
          c: "ğŒ²",
          d: "ğŒ³",
          e: "ğŒ´",
          f: "ğ†",
          g: "ğŒ²",
          h: "ğŒ·",
          i: "ğŒ¹",
          j: "ğŒ¾",
          k: "ğŒº",
          l: "ğŒ»",
          m: "ğŒ¼",
          n: "ğŒ½",
          o: "ğŒ¿",
          p: "ğ€",
          q: "ğŒµ",
          r: "ğ‚",
          s: "ğƒ",
          t: "ğ„",
          u: "ğŒ¿",
          v: "ğ…",
          w: "ğ…",
          x: "ğŒºğƒ",
          y: "ğŒ¹",
          z: "ğŒ¶",
        },
        hungarian: {
          a: "ğ²€",
          b: "ğ²‚",
          c: "ğ²„",
          d: "ğ²†",
          e: "ğ²ˆ",
          f: "ğ²Š",
          g: "ğ²Œ",
          h: "ğ²",
          i: "ğ²",
          j: "ğ²’",
          k: "ğ²”",
          l: "ğ²–",
          m: "ğ²˜",
          n: "ğ²š",
          o: "ğ²œ",
          p: "ğ²",
          q: "ğ²”",
          r: "ğ²¢",
          s: "ğ²¤",
          t: "ğ²¦",
          u: "ğ²¨",
          v: "ğ²ª",
          w: "ğ²ª",
          x: "ğ²”ğ²¤",
          y: "ğ²",
          z: "ğ²°",
        },
        turkic: {
          a: "ğ°",
          b: "ğ°‰",
          c: "ğ°²",
          d: "ğ°“",
          e: "ğ°€",
          f: "ğ°¯",
          g: "ğ°",
          h: "ğ°´",
          i: "ğ°ƒ",
          j: "ğ°˜",
          k: "ğ°š",
          l: "ğ°",
          m: "ğ°¢",
          n: "ğ°¤",
          o: "ğ°†",
          p: "ğ°¯",
          q: "ğ°´",
          r: "ğ°º",
          s: "ğ°½",
          t: "ğ±ƒ",
          u: "ğ°†",
          v: "ğ°‹",
          w: "ğ°ƒ",
          x: "ğ°šğ°½",
          y: "ğ°–",
          z: "ğ°”",
        },
        cirth: {
          a: "áš«",
          b: "á›”",
          c: "á›¤",
          d: "á›",
          e: "á›Ÿ",
          f: "áš ",
          g: "áš¸",
          h: "ášº",
          i: "á›",
          j: "á›ƒ",
          k: "á›¤",
          l: "á›š",
          m: "á›—",
          n: "áš¾",
          o: "á›Ÿ",
          p: "á›ˆ",
          q: "á›¤",
          r: "áš±",
          s: "á›‹",
          t: "á›",
          u: "áš¢",
          v: "áš¹",
          w: "áš¹",
          x: "á›¤á›‹",
          y: "áš£",
          z: "á›‰",
        },
      };

      // Rune names from various poems
      const runeNames: Record<string, Record<string, string>> = {
        elder: {
          f: "fehu (cattle)",
          u: "uruz (aurochs)",
          a: "ansuz (god)",
          r: "raido (journey)",
          k: "kenaz (torch)",
          g: "gebo (gift)",
          w: "wunjo (joy)",
          h: "hagalaz (hail)",
          n: "naudhiz (need)",
          i: "isa (ice)",
          j: "jera (year)",
          e: "ehwaz (horse)",
          p: "perthro (lot cup)",
          s: "sowilo (sun)",
          t: "tiwaz (Tyr)",
          b: "berkano (birch)",
          m: "mannaz (man)",
          l: "laguz (water)",
          d: "dagaz (day)",
          o: "othala (heritage)",
        },
      };

      // Rune poem excerpts
      const poemExcerpts: Record<string, string> = {
        elder:
          "áš  Fehu: Wealth is a comfort to all, yet must each give freely if glory before the gods they would gain.",
        younger:
          "áš  FÃ©: Money causes strife among kinsmen; the wolf grows up in the woods.",
        anglosaxon:
          "áš  Feoh: Wealth is a comfort to everyone, yet must each give it away freely, if before the Lord his lot of honour he would obtain.",
      };

      const runeMap = runicSets[alphabet] || runicSets.elder;
      let result = workingText
        .toLowerCase()
        .split("")
        .map((c) => {
          const rune = runeMap[c] || c;
          if (showRuneNames && runeNames.elder && runeNames.elder[c]) {
            return `${rune}(${runeNames.elder[c]})`;
          }
          return rune;
        })
        .join("");

      if (medieval) {
        result = "á›­ " + result + " á›­";
      }

      if (showPoemExcerpt && poemExcerpts[alphabet]) {
        result = result + "\n\n--- Rune Poem ---\n" + poemExcerpts[alphabet];
      }

      return result;
    }
    case "old-english": {
      const era = customSettings.era || "medieval";
      const useThorn = customSettings.addThorn !== false;
      const useEth = customSettings.useEth !== false;
      const useAsh = customSettings.useAsh !== false;
      const useWynn = customSettings.useWynn === true;
      const useYogh = customSettings.useYogh === true;
      const convertToFuthorc = customSettings.convertToFuthorc === true;
      const showPronunciation = customSettings.showPronunciation === true;

      let result = workingText;

      // Common Old English character replacements
      if (useThorn) {
        result = result.replace(/th/gi, "Ã¾");
        result = result.replace(/Th/g, "Ã");
      }

      if (useEth) {
        // Eth for voiced th sound (typically between vowels)
        result = result.replace(/([aeiou])th([aeiou])/gi, "$1Ã°$2");
      }

      if (useAsh) {
        result = result.replace(/ae/gi, "Ã¦");
        result = result.replace(/Ae/g, "Ã†");
      }

      if (useWynn) {
        result = result.replace(/w/gi, "Æ¿");
        result = result.replace(/W/g, "Ç·");
      }

      if (useYogh) {
        result = result.replace(/gh/gi, "È");
        result = result.replace(/Gh/g, "Èœ");
      }

      // Era-specific transformations
      const eraTransformations: Record<string, (text: string) => string> = {
        anglosaxon: (t) =>
          t.replace(/oo/gi, "Å").replace(/ee/gi, "Ä“").replace(/ea/gi, "Ä“a"),
        earlyOE: (t) => t.replace(/oo/gi, "Å").replace(/ee/gi, "Ä“"),
        classicalOE: (t) =>
          t.replace(/oo/gi, "Å").replace(/ee/gi, "Ä“").replace(/sc/gi, "sc"),
        lateOE: (t) =>
          t.replace(/oo/gi, "Å").replace(/ee/gi, "Ä“").replace(/cw/gi, "qu"),
        medieval: (t) =>
          t
            .replace(/v/gi, "u")
            .replace(/j/gi, "i")
            .replace(/u(?=[aeiou])/gi, "v"),
        middleEnglish: (t) => t.replace(/gh/gi, "È").replace(/wh/gi, "hw"),
        chaucerian: (t) =>
          t
            .replace(/you/gi, "ye")
            .replace(/your/gi, "youre")
            .replace(/have/gi, "han"),
        shakespearean: (t) =>
          t
            .replace(/you/gi, "thou")
            .replace(/your/gi, "thy")
            .replace(/are/gi, "art")
            .replace(/have/gi, "hath")
            .replace(/do/gi, "doth")
            .replace(/will/gi, "wilt"),
        kjv: (t) =>
          t
            .replace(/you/gi, "thee")
            .replace(/your/gi, "thine")
            .replace(/are/gi, "art")
            .replace(/have/gi, "hast")
            .replace(/is/gi, "be")
            .replace(/said/gi, "saith"),
        elizabethan: (t) =>
          t
            .replace(/you/gi, "thou")
            .replace(/your/gi, "thy")
            .replace(/are/gi, "art")
            .replace(/have/gi, "hast"),
        victorian: (t) => t.replace(/you/gi, "thee").replace(/has/gi, "hath"),
        beowulf: (t) =>
          t
            .replace(/the/gi, "se")
            .replace(/and/gi, "ond")
            .replace(/king/gi, "cyning")
            .replace(/warrior/gi, "wiga"),
        wessex: (t) => t.replace(/i/gi, "ic").replace(/was/gi, "wÃ¦s"),
        mercian: (t) => t.replace(/ea/gi, "e").replace(/eo/gi, "e"),
        northumbrian: (t) => t.replace(/ea/gi, "Ã¦").replace(/eo/gi, "e"),
        kentish: (t) => t.replace(/y/gi, "e").replace(/ie/gi, "e"),
        westSaxon: (t) => t.replace(/was/gi, "wÃ¦s").replace(/they/gi, "hie"),
        poetic: (t) =>
          "HwÃ¦t! " + t.replace(/the/gi, "se").replace(/and/gi, "ond"),
      };

      if (eraTransformations[era]) {
        result = eraTransformations[era](result);
      }

      // Optional Futhorc runic conversion
      if (convertToFuthorc) {
        const futhorc: Record<string, string> = {
          a: "ášª",
          b: "á›’",
          c: "áš³",
          d: "á›",
          e: "á›–",
          f: "áš ",
          g: "áš·",
          h: "áš»",
          i: "á›",
          j: "á›¡",
          k: "áš³",
          l: "á›š",
          m: "á›—",
          n: "áš¾",
          o: "áš©",
          p: "á›ˆ",
          q: "áš³áš¹",
          r: "áš±",
          s: "á›‹",
          t: "á›",
          u: "áš¢",
          v: "áš¹",
          w: "áš¹",
          x: "áš³á›‹",
          y: "áš£",
          z: "á›‰",
          Ã¾: "áš¦",
          Ã°: "áš¦",
          Ã¦: "áš«",
          Æ¿: "áš¹",
        };
        result = result
          .toLowerCase()
          .split("")
          .map((c) => futhorc[c] || c)
          .join("");
      }

      // Optional pronunciation guide
      if (showPronunciation) {
        const pronunciations: Record<string, string> = {
          Ã¾: "[th]",
          Ã°: "[th/dh]",
          Ã¦: "[a]",
          Æ¿: "[w]",
          È: "[y/gh]",
          Å: "[oh]",
          Ä“: "[ay]",
          Ä: "[ah]",
        };
        let guide = "\n\n--- Pronunciation Guide ---\n";
        Object.entries(pronunciations).forEach(([char, pron]) => {
          if (result.includes(char)) {
            guide += `${char} = ${pron}\n`;
          }
        });
        result += guide;
      }

      return result;
    }
    case "braille": {
      const showIndicator = customSettings.showIndicator !== false;
      const showCap = customSettings.showCapitalIndicator !== false;
      const grade = customSettings.grade || "grade1";

      // Basic Grade 1 implementation with indicators
      let result = toBraille(workingText, showIndicator);

      if (showCap) {
        // Simple capital indicator addition
        result = workingText
          .split("")
          .map((char, i) => {
            const b = toBraille(char, showIndicator);
            if (/[A-Z]/.test(char)) return "â  " + b;
            return b;
          })
          .join("");
      }

      return result;
    }
    case "sign-language": {
      const format = customSettings.format || "emoji";
      const separator =
        customSettings.separator === "dash"
          ? "-"
          : customSettings.separator === "none"
            ? ""
            : " ";

      const signFormats: Record<string, Record<string, string>> = {
        emoji: {
          a: "ğŸ¤Ÿ",
          b: "ğŸ¤˜",
          c: "ğŸ¤™",
          d: "ğŸ‘†",
          e: "âœŠ",
          f: "ğŸ¤",
          g: "ğŸ”«",
          h: "ğŸ¤›",
          i: "ğŸ¤",
          j: "ğŸ¤Œ",
          k: "âœŒ",
          l: "ğŸ¤Ÿ",
          m: "ğŸ¤œ",
          n: "ğŸ‘‡",
          o: "ğŸ‘Œ",
          p: "ğŸ‘†",
          q: "ğŸ¤™",
          r: "ğŸ¤",
          s: "âœŠ",
          t: "ğŸ‘",
          u: "â˜",
          v: "âœŒ",
          w: "ğŸ¤Ÿ",
          x: "ğŸ¤",
          y: "ğŸ¤™",
          z: "ğŸ‘‰",
        },
        unicode: {
          a: "ğŸ–ï¸",
          b: "âœ‹",
          c: "ğŸ¤",
          d: "â˜ï¸",
          e: "âœŠ",
          f: "ğŸ¤",
          g: "ğŸ‘ˆ",
          h: "ğŸ¤˜",
          i: "ğŸ¤™",
          j: "ğŸ‘‹",
          k: "ğŸ––",
          l: "ğŸ¤Ÿ",
          m: "ğŸ‘Š",
          n: "ğŸ‘",
          o: "ğŸ‘Œ",
          p: "ğŸ¤Œ",
          q: "ğŸ¤",
          r: "ğŸ¤",
          s: "âœŠ",
          t: "ğŸ‘",
          u: "ğŸ‘†",
          v: "âœŒï¸",
          w: "ğŸ‘‹",
          x: "ğŸ«µ",
          y: "ğŸ¤™",
          z: "ğŸ‘‰",
        },
        codes: {
          a: "[A]",
          b: "[B]",
          c: "[C]",
          d: "[D]",
          e: "[E]",
          f: "[F]",
          g: "[G]",
          h: "[H]",
          i: "[I]",
          j: "[J]",
          k: "[K]",
          l: "[L]",
          m: "[M]",
          n: "[N]",
          o: "[O]",
          p: "[P]",
          q: "[Q]",
          r: "[R]",
          s: "[S]",
          t: "[T]",
          u: "[U]",
          v: "[V]",
          w: "[W]",
          x: "[X]",
          y: "[Y]",
          z: "[Z]",
        },
        descriptions: {
          a: "(fist-thumb)",
          b: "(flat-thumb)",
          c: "(curved)",
          d: "(point-up)",
          e: "(fist)",
          f: "(ok-3up)",
          g: "(thumb-point)",
          h: "(flat-2)",
          i: "(pinky-up)",
          j: "(j-motion)",
          k: "(2up-thumb)",
          l: "(l-shape)",
          m: "(3-under)",
          n: "(2-under)",
          o: "(o-shape)",
          p: "(k-down)",
          q: "(g-down)",
          r: "(crossed)",
          s: "(fist)",
          t: "(thumb-fist)",
          u: "(2-up)",
          v: "(peace)",
          w: "(3-up)",
          x: "(hook)",
          y: "(hang-loose)",
          z: "(z-motion)",
        },
      };

      const signMap = signFormats[format] || signFormats.emoji;

      return workingText
        .toLowerCase()
        .split("")
        .map((c) => {
          if (c === " ") return "  ";
          return signMap[c] || c;
        })
        .join(separator);
    }
    case "ascii-art":
      return generateAsciiArt(workingText, customSettings.font || "std");

    // Weird and Creepy text tools with proper customization
    case "weird-text": {
      const fontStyle = customSettings.fontStyle || "ransomNote";
      const level = customSettings.level || 5;
      const mixFonts = customSettings.mix === true;

      // Apply the selected font style first
      let styledText = applyFontStyle(workingText, fontStyle);

      if (mixFonts) {
        // Mix different fonts based on level - more random with higher level
        const fontMaps = [
          GOTHIC_MAP,
          BOLD_MAP,
          ITALIC_MAP,
          CURSIVE_MAP,
          MONOSPACE_MAP,
          BUBBLE_MAP,
        ];
        styledText = workingText
          .split("")
          .map((c, i) => {
            if (c === " ") return c;
            const fontIndex =
              (i + Math.floor(Math.random() * level)) % fontMaps.length;
            return mapChars(c, fontMaps[fontIndex]);
          })
          .join("");
      }

      // Apply weirdness effects based on level (visible changes)
      if (level > 3) {
        const combiningMarks = [
          "\u0300",
          "\u0301",
          "\u0302",
          "\u0303",
          "\u0304",
          "\u0305",
          "\u0306",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u030B",
          "\u030C",
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
        ];
        const markCount = Math.floor((level - 3) / 2);
        styledText = styledText
          .split("")
          .map((c) => {
            if (c === " " || c.charCodeAt(0) < 32) return c;
            let result = c;
            for (let i = 0; i < markCount; i++) {
              if (Math.random() < level / 20) {
                result +=
                  combiningMarks[
                    Math.floor(Math.random() * combiningMarks.length)
                  ];
              }
            }
            return result;
          })
          .join("");
      }

      // At high levels, randomly insert weird symbols between chars
      if (level > 10) {
        const weirdSymbols = [
          "Ì·",
          "Ì¸",
          "Ì¶",
          "Ìµ",
          "Ì´",
          "Íœ",
          "Í",
          "Í ",
          "Í…",
          "Ì©",
          "Ì¡",
          "Ì¢",
          "Ì§",
          "Ì¨",
        ];
        styledText = styledText
          .split("")
          .map((c) => {
            if (c === " ") return c;
            if (Math.random() < (level - 10) / 20) {
              return (
                c +
                weirdSymbols[Math.floor(Math.random() * weirdSymbols.length)]
              );
            }
            return c;
          })
          .join("");
      }

      return styledText;
    }
    case "creepy-text": {
      const fontStyle = customSettings.fontStyle || "gothic";
      const creepiness = customSettings.creepiness || 5;
      const addShadow = customSettings.shadow === true;

      // Apply creepy font style
      let styledText = applyFontStyle(workingText, fontStyle);

      // Creepy symbols to insert based on creepiness level
      const creepySymbols = ["\u0337", "\u0338", "\u0336", "\u0335", "\u0334"];
      const heavyMarks = [
        "\u0300",
        "\u0301",
        "\u0302",
        "\u0303",
        "\u0316",
        "\u0317",
        "\u0324",
        "\u0325",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
      ];
      const shadowChars = ["â–‘", "â–’", "â–“", "â–ˆ", "â–„", "â–€"];

      // Scale effect intensity with creepiness
      const numEffects = Math.max(1, Math.floor(creepiness / 3));
      styledText = styledText
        .split("")
        .map((c, i) => {
          if (c === " ") return c;
          let char = c;

          // Add zalgo-like effects based on creepiness
          for (let j = 0; j < numEffects; j++) {
            if (Math.random() < creepiness / 15) {
              char +=
                creepySymbols[Math.floor(Math.random() * creepySymbols.length)];
            }
          }

          // At higher creepiness, add heavy combining marks
          if (creepiness > 8) {
            const extraMarks = Math.floor((creepiness - 8) / 2);
            for (let j = 0; j < extraMarks; j++) {
              char += heavyMarks[Math.floor(Math.random() * heavyMarks.length)];
            }
          }

          // At max creepiness, full chaos
          if (creepiness > 15) {
            if (Math.random() < 0.3) {
              char +=
                heavyMarks[Math.floor(Math.random() * heavyMarks.length)] +
                heavyMarks[Math.floor(Math.random() * heavyMarks.length)];
            }
          }

          return char;
        })
        .join("");

      // Add shadow characters if enabled
      if (addShadow) {
        styledText = styledText
          .split("")
          .map((c, i) => {
            if (c === " ") return c;
            if (i % Math.max(4 - Math.floor(creepiness / 5), 2) === 0) {
              return (
                shadowChars[Math.floor(Math.random() * shadowChars.length)] + c
              );
            }
            return c;
          })
          .join("");
      }

      return styledText;
    }

    // SYMBOLS TOOLS
    case "text-symbols": {
      const category = customSettings.category || "all";
      const density = customSettings.density || 5;

      const symbolSets: Record<string, string[]> = {
        arrows: [
          "â†’",
          "â†",
          "â†‘",
          "â†“",
          "â†”",
          "â‡’",
          "â‡",
          "â‡‘",
          "â‡“",
          "âœ",
          "â¡",
          "â¬…",
          "â¬†",
          "â¬‡",
          "â†—",
          "â†˜",
          "â†™",
          "â†–",
          "â¤´",
          "â¤µ",
          "â†ª",
          "â†©",
          "âŸ¶",
          "âŸµ",
        ],
        stars: [
          "â˜…",
          "â˜†",
          "âœ¦",
          "âœ§",
          "âœª",
          "âœ«",
          "âœ¬",
          "âœ­",
          "âœ®",
          "âœ¯",
          "â­",
          "ğŸŒŸ",
          "âœ°",
          "â‹†",
          "âœµ",
          "âœ¶",
          "âœ·",
          "âœ¸",
          "âœ¹",
        ],
        hearts: [
          "â™¥",
          "â™¡",
          "â¤",
          "â¥",
          "â£",
          "ğŸ’•",
          "ğŸ’–",
          "ğŸ’—",
          "ğŸ’˜",
          "ğŸ’",
          "ğŸ’",
          "ğŸ’Ÿ",
          "â¤ï¸â€ğŸ”¥",
          "ğŸ©·",
          "ğŸ©µ",
          "ğŸ©¶",
          "ğŸ’œ",
          "ğŸ§¡",
          "ğŸ’›",
          "ğŸ’š",
        ],
        math: [
          "Â±",
          "Ã—",
          "Ã·",
          "â‰ ",
          "â‰¤",
          "â‰¥",
          "âˆ",
          "âˆ‘",
          "âˆ",
          "âˆš",
          "âˆ«",
          "Ï€",
          "Î©",
          "âˆ‚",
          "âˆ†",
          "âˆ‡",
          "âˆˆ",
          "âˆ‰",
          "âŠ‚",
          "âŠƒ",
          "âˆª",
          "âˆ©",
          "âˆ§",
          "âˆ¨",
        ],
        currency: [
          "$",
          "â‚¬",
          "Â£",
          "Â¥",
          "â‚¹",
          "â‚½",
          "â‚¿",
          "Â¢",
          "â‚©",
          "â‚ª",
          "â‚®",
          "â‚±",
          "â‚¸",
          "â‚«",
          "â‚µ",
          "â‚¡",
          "â‚¢",
          "â‚£",
          "â‚¤",
          "â‚¥",
          "â‚¦",
        ],
        dividers: [
          "â”€",
          "â•",
          "â•‘",
          "â—ˆ",
          "â”",
          "â”ƒ",
          "â•Œ",
          "â•",
          "â”„",
          "â”…",
          "â”ˆ",
          "â”‰",
          "â•´",
          "â•µ",
          "â•¶",
          "â•·",
          "â€•",
          "â¸º",
          "â¸»",
        ],
        flowers: [
          "âœ¿",
          "â€",
          "â",
          "âœ¾",
          "âœ½",
          "âƒ",
          "ğŸ’",
          "ğŸŒ¸",
          "ğŸŒ¹",
          "ğŸŒº",
          "ğŸŒ»",
          "ğŸŒ¼",
          "ğŸŒ·",
          "ğŸµ",
          "ğŸ’®",
          "ğŸŒº",
        ],
        music: [
          "â™©",
          "â™ª",
          "â™«",
          "â™¬",
          "ğŸµ",
          "ğŸ¶",
          "ğŸ¼",
          "ğ„",
          "ğ„¢",
          "â™­",
          "â™®",
          "â™¯",
          "ğŸ¸",
          "ğŸ¹",
          "ğŸ·",
          "ğŸº",
          "ğŸ¥",
        ],
        weather: [
          "â˜€",
          "â˜",
          "â›…",
          "ğŸŒ¤",
          "ğŸŒ¥",
          "ğŸŒ¦",
          "ğŸŒ§",
          "â›ˆ",
          "ğŸŒ©",
          "ğŸŒª",
          "â„",
          "âš¡",
          "ğŸŒˆ",
          "ğŸŒŠ",
          "ğŸ’§",
          "â˜ƒ",
          "â›„",
        ],
        zodiac: [
          "â™ˆ",
          "â™‰",
          "â™Š",
          "â™‹",
          "â™Œ",
          "â™",
          "â™",
          "â™",
          "â™",
          "â™‘",
          "â™’",
          "â™“",
        ],
        chess: ["â™”", "â™•", "â™–", "â™—", "â™˜", "â™™", "â™š", "â™›", "â™œ", "â™", "â™", "â™Ÿ"],
        dice: ["âš€", "âš", "âš‚", "âšƒ", "âš„", "âš…"],
        cards: [
          "â™ ",
          "â™£",
          "â™¥",
          "â™¦",
          "ğŸ‚¡",
          "ğŸ‚¢",
          "ğŸ‚£",
          "ğŸ‚¤",
          "ğŸ‚¥",
          "ğŸ‚¦",
          "ğŸ‚§",
          "ğŸ‚¨",
          "ğŸƒ",
        ],
        animals: [
          "ğŸ±",
          "ğŸ¶",
          "ğŸ°",
          "ğŸ¦Š",
          "ğŸ»",
          "ğŸ¼",
          "ğŸ¨",
          "ğŸ¦",
          "ğŸ¯",
          "ğŸ¸",
          "ğŸµ",
          "ğŸ™",
          "ğŸ¦‹",
          "ğŸ",
          "ğŸ",
          "ğŸ¦„",
          "ğŸº",
          "ğŸ¦‡",
        ],
        food: [
          "ğŸ•",
          "ğŸ”",
          "ğŸŸ",
          "ğŸŒ®",
          "ğŸ©",
          "ğŸª",
          "ğŸ§",
          "ğŸ°",
          "ğŸ‚",
          "ğŸ­",
          "ğŸ«",
          "ğŸ¬",
          "ğŸ¦",
          "ğŸ“",
          "ğŸ",
          "ğŸŒ",
          "ğŸ‡",
          "ğŸ‰",
        ],
        geometric: [
          "â—†",
          "â—",
          "â– ",
          "â–²",
          "â—‡",
          "â—‹",
          "â–¡",
          "â–³",
          "â–¶",
          "â—€",
          "â–¼",
          "â–½",
          "â¬ ",
          "â¬¡",
          "â¬¢",
          "â¬£",
          "â¬¤",
          "â¬¥",
          "â¬¦",
        ],
        boxDrawing: [
          "â”Œ",
          "â”",
          "â””",
          "â”˜",
          "â”œ",
          "â”¤",
          "â”¬",
          "â”´",
          "â”¼",
          "â•",
          "â•‘",
          "â•”",
          "â•—",
          "â•š",
          "â•",
          "â• ",
          "â•£",
          "â•¦",
          "â•©",
          "â•¬",
        ],
        braille: [
          "â ",
          "â ƒ",
          "â ‡",
          "â ",
          "â Ÿ",
          "â ¿",
          "â¡¿",
          "â£¿",
          "â ‰",
          "â Š",
          "â ‹",
          "â Œ",
          "â ",
          "â ",
          "â ‘",
          "â ’",
        ],
        religious: [
          "âœ",
          "â˜ª",
          "âœ¡",
          "â˜¸",
          "â˜¯",
          "â˜¦",
          "â›©",
          "ğŸ•‰",
          "ğŸ›",
          "â¸¸",
          "â˜¥",
          "â™±",
        ],
        planets: ["â˜¿", "â™€", "â™‚", "â™ƒ", "â™„", "â™…", "â™†", "âš³", "âš´", "âšµ", "âš¶", "âš·"],
        crosses: ["âœš", "âœ", "âœ", "âœŸ", "â€ ", "â€¡", "â™±", "â™°", "â˜©", "â¸¸"],
        snowflakes: ["â„", "â…", "â†", "âœ»", "âœ¼", "âœ½", "âœ¾", "âŠ", "â‹"],
        bullets: ["â€¢", "â—¦", "â€£", "âƒ", "â–ª", "â–«", "âŠ™", "âŠš", "âœ¦", "âœ§", "â¬©", "â¬ª"],
        all: [
          "â˜…",
          "â™¥",
          "â†’",
          "âœ¦",
          "â™ ",
          "â™£",
          "â™¦",
          "â˜†",
          "â—†",
          "â—",
          "â– ",
          "â–²",
          "â—‡",
          "â—‹",
          "â–¡",
          "â–³",
          "âœ¿",
          "â€",
          "â™ª",
          "â™«",
          "âš¡",
          "â„",
          "â˜€",
          "â˜",
        ],
      };

      const symbols = symbolSets[category] || symbolSets.all;
      const insertFreq = Math.max(11 - density, 1);

      return workingText
        .split("")
        .map((c, i) => {
          if (c === " ") return c;
          if (i % insertFreq === 0) {
            return c + symbols[Math.floor(Math.random() * symbols.length)];
          }
          return c;
        })
        .join("");
    }
    case "aesthetic-symbols": {
      const aestheticStyle = customSettings.style || "sparkle";
      const wrap = customSettings.wrap !== false;

      const styleSets: Record<
        string,
        { symbols: string[]; prefix: string; suffix: string }
      > = {
        sparkle: {
          symbols: ["âœ§", "âœ¦", "ãƒ»", "Ëš", "âœ©"],
          prefix: "âœ§ï½¥ï¾Ÿ: *",
          suffix: "*:ï½¥ï¾Ÿâœ§",
        },
        celestial: {
          symbols: ["â˜†", "â˜…", "âœ«", "âœ¬", "â˜¾", "â˜½"],
          prefix: "â˜†.ã€‚.:*",
          suffix: "*:.ã€‚.â˜†",
        },
        floral: {
          symbols: ["â€", "âœ¿", "â", "âƒ", "âœ¾", "âœ½"],
          prefix: "âœ¿ï¾Ÿâ€ï¾Ÿ",
          suffix: "ï¾Ÿâ€ï¾Ÿâœ¿",
        },
        mystical: {
          symbols: ["âœ¦", "âœ§", "â‹†", "Ëš", "âº"],
          prefix: "â‹†ï½¡Ëšâœ©",
          suffix: "âœ©Ëšï½¡â‹†",
        },
        ocean: {
          symbols: ["ğŸŒŠ", "âœ§", "Ëš", "â‹†", "ğŸš"],
          prefix: "ğŸŒŠâœ§Ëš",
          suffix: "Ëšâœ§ğŸŒŠ",
        },
        butterfly: {
          symbols: ["ğŸ¦‹", "âœ§", "Ëš", "â‹†", "âœ¦"],
          prefix: "ğŸ¦‹Â·âœ§",
          suffix: "âœ§Â·ğŸ¦‹",
        },
        crystal: {
          symbols: ["ğŸ’", "âœ§", "Ëš", "â‹†", "âœ¦"],
          prefix: "ğŸ’âœ§Ëš",
          suffix: "Ëšâœ§ğŸ’",
        },
        moonlight: {
          symbols: ["ğŸŒ™", "â˜½", "âœ§", "Ëš", "â‹†"],
          prefix: "ğŸŒ™â˜½Â·",
          suffix: "Â·â˜½ğŸŒ™",
        },
        sunrise: {
          symbols: ["ğŸŒ…", "âœ§", "Ëš", "â‹†", "â˜€"],
          prefix: "ğŸŒ…âœ§Ëš",
          suffix: "Ëšâœ§ğŸŒ…",
        },
        aurora: {
          symbols: ["ğŸŒŒ", "âœ§", "Ëš", "â‹†", "âœ¦"],
          prefix: "ğŸŒŒÂ·âœ§",
          suffix: "âœ§Â·ğŸŒŒ",
        },
        garden: {
          symbols: ["ğŸŒº", "ğŸŒ¸", "âœ¿", "â€", "ğŸŒ»"],
          prefix: "ğŸŒ¸âœ¿â€",
          suffix: "â€âœ¿ğŸŒ¸",
        },
        starryNight: {
          symbols: ["â­", "ğŸŒŸ", "âœ¦", "â˜†", "â˜…"],
          prefix: "â­ğŸŒŸâœ¦",
          suffix: "âœ¦ğŸŒŸâ­",
        },
        cottagecore: {
          symbols: ["ğŸŒ¿", "ğŸ„", "ğŸŒ»", "ğŸ§º", "ğŸŒ¾"],
          prefix: "ğŸŒ¿ğŸ„Â·",
          suffix: "Â·ğŸ„ğŸŒ¿",
        },
        darkAcademia: {
          symbols: ["ğŸ“š", "ğŸ–‹", "â˜¾", "âœ§", "â‹†"],
          prefix: "ğŸ“šâ˜¾Â·",
          suffix: "Â·â˜¾ğŸ“š",
        },
        kawaii: {
          symbols: ["â™¡", "âœ§", "Ëš", "â‚Š", "â"],
          prefix: "â™¡Ëšâ‚ŠÂ·",
          suffix: "Â·â‚ŠËšâ™¡",
        },
        vaporwave: {
          symbols: ["âœ§", "Ëš", "â‚Š", "âº", "â‹†"],
          prefix: "âœ§Ëšâ‚ŠÂ·",
          suffix: "Â·â‚ŠËšâœ§",
        },
        y2k: {
          symbols: ["âœ°", "â‹†", "âœ§", "Ëš", "â˜…"],
          prefix: "âœ°â‹†Â·",
          suffix: "Â·â‹†âœ°",
        },
        fairy: {
          symbols: ["âœ¦", "Ëš", "âº", "â‹†", "âœ§"],
          prefix: "âœ¦ËšâºÂ·",
          suffix: "Â·âºËšâœ¦",
        },
        royal: {
          symbols: ["â™”", "âœ¦", "âšœ", "âœ§", "â˜…"],
          prefix: "â™”âšœâœ¦",
          suffix: "âœ¦âšœâ™”",
        },
        minimalist: {
          symbols: ["â¸°", "Â·", "Ëš", "â‹…", "âˆ˜"],
          prefix: "Â· Â· Â·",
          suffix: "Â· Â· Â·",
        },
        boho: {
          symbols: ["â˜½", "âœ§", "â‹†", "Ëš", "âœ¦"],
          prefix: "â˜½âœ§â‹†",
          suffix: "â‹†âœ§â˜½",
        },
        celestialDark: {
          symbols: ["â˜†", "âœ§", "â‹†", "â˜…", "âœ¦"],
          prefix: "â˜…â˜†âœ§",
          suffix: "âœ§â˜†â˜…",
        },
        pastelDream: {
          symbols: ["ğŸ§¸", "âœ§", "Ëš", "â‹†", "â™¡"],
          prefix: "ğŸ§¸âœ§Ëš",
          suffix: "Ëšâœ§ğŸ§¸",
        },
        witchy: {
          symbols: ["â˜½", "â›¤", "âœ§", "â‹†", "âš—"],
          prefix: "â˜½â›¤Â·",
          suffix: "Â·â›¤â˜½",
        },
        retro: {
          symbols: ["âœ°", "â˜…", "â˜†", "âœµ", "âœ·"],
          prefix: "âœ°â˜…â˜†",
          suffix: "â˜†â˜…âœ°",
        },
        cyberpunk: {
          symbols: ["âŸ¨", "âŸ©", "âŒˆ", "âŒ‰", "âŒŠ", "âŒ‹"],
          prefix: "âŸ¨âŒˆâŒŠ",
          suffix: "âŒ‹âŒ‰âŸ©",
        },
        steampunk: {
          symbols: ["âš™", "â›­", "âš—", "âš’", "â›"],
          prefix: "âš™â›­Â·",
          suffix: "Â·â›­âš™",
        },
        gothic: {
          symbols: ["â˜ ", "âš°", "âœ", "â˜¾", "â›¤"],
          prefix: "â˜ âœâ˜¾",
          suffix: "â˜¾âœâ˜ ",
        },
        angel: {
          symbols: ["â™¡", "âœ°", "âœ§", "â‹†", "â˜"],
          prefix: "â™¡âœ°âœ§",
          suffix: "âœ§âœ°â™¡",
        },
        demon: {
          symbols: ["â›§", "â›¤", "â¸¸", "â˜ ", "â€ "],
          prefix: "â›§â›¤â¸¸",
          suffix: "â¸¸â›¤â›§",
        },
        sakura: {
          symbols: ["ğŸŒ¸", "â€", "âœ¿", "ğŸµ", "ğŸ’®"],
          prefix: "ğŸŒ¸â€âœ¿",
          suffix: "âœ¿â€ğŸŒ¸",
        },
        snow: {
          symbols: ["â„", "â…", "â†", "Ëš", "â‹†"],
          prefix: "â„â…â†",
          suffix: "â†â…â„",
        },
        fire: {
          symbols: ["ğŸ”¥", "âœ§", "â‹†", "Ëš", "ğŸ’«"],
          prefix: "ğŸ”¥âœ§Ëš",
          suffix: "Ëšâœ§ğŸ”¥",
        },
        ice: {
          symbols: ["â„", "âœ§", "â‹†", "Ëš", "ğŸ’"],
          prefix: "â„âœ§Ëš",
          suffix: "Ëšâœ§â„",
        },
        thunder: {
          symbols: ["âš¡", "âœ§", "â‹†", "Ëš", "â˜…"],
          prefix: "âš¡âœ§Ëš",
          suffix: "Ëšâœ§âš¡",
        },
        rainbow: {
          symbols: ["ğŸŒˆ", "âœ§", "â‹†", "Ëš", "â˜…"],
          prefix: "ğŸŒˆâœ§Ëš",
          suffix: "Ëšâœ§ğŸŒˆ",
        },
        vintage: {
          symbols: ["â¦", "âœ§", "â‹†", "Ëš", "â§"],
          prefix: "â¦âœ§Ëš",
          suffix: "Ëšâœ§â¦",
        },
        grunge: {
          symbols: ["âœ—", "âœ˜", "âœ•", "â˜’", "âœ–"],
          prefix: "âœ—âœ˜âœ•",
          suffix: "âœ•âœ˜âœ—",
        },
        ethereal: {
          symbols: ["âœ§", "â‹†", "Ëš", "âº", "Â·"],
          prefix: "âœ§â‹†Ëš",
          suffix: "Ëšâ‹†âœ§",
        },
        dreamcore: {
          symbols: ["â˜", "âœ§", "â‹†", "Ëš", "ğŸ’«"],
          prefix: "â˜âœ§Ëš",
          suffix: "Ëšâœ§â˜",
        },
        softGirl: {
          symbols: ["ğŸ§¸", "ğŸŒ¸", "â™¡", "âœ§", "Ëš"],
          prefix: "ğŸ§¸ğŸŒ¸â™¡",
          suffix: "â™¡ğŸŒ¸ğŸ§¸",
        },
      };

      const styleConfig = styleSets[aestheticStyle] || styleSets.sparkle;
      let result = workingText
        .split("")
        .map((c, i) => {
          if (c === " ")
            return (
              " " + styleConfig.symbols[i % styleConfig.symbols.length] + " "
            );
          return c;
        })
        .join("");

      if (wrap) {
        result = styleConfig.prefix + " " + result + " " + styleConfig.suffix;
      }

      return result;
    }
    case "special-characters": {
      const charType = customSettings.charType || "decorative";
      const addSpacing = customSettings.spacing === true;

      const charSets: Record<string, string[]> = {
        decorative: [
          "â€»",
          "â€ ",
          "â€¡",
          "Â§",
          "Â¶",
          "â€¢",
          "â—¦",
          "â€£",
          "â‚",
          "â§",
          "â˜™",
          "â¦",
        ],
        technical: ["âŒ˜", "âŒ¥", "â‡§", "âŒƒ", "â‹", "â", "âŒ«", "â‡¥", "âŒ§", "â"],
        legal: ["Â©", "Â®", "â„¢", "â„ ", "â„—", "Â§", "Â¶", "â„–", "â„ƒ", "â„‰"],
        musical: ["â™©", "â™ª", "â™«", "â™¬", "ğ„", "ğ„¢", "ğ„«", "ğ„ª", "â™­", "â™®", "â™¯"],
        mathematical: [
          "âˆ‘",
          "âˆ",
          "âˆ«",
          "âˆš",
          "âˆ‚",
          "âˆ†",
          "âˆ‡",
          "âˆˆ",
          "âˆ‰",
          "âŠ‚",
          "âŠƒ",
          "âˆª",
          "âˆ©",
          "âˆ§",
          "âˆ¨",
          "âˆ€",
          "âˆƒ",
          "âˆ„",
        ],
        greek: [
          "Î±",
          "Î²",
          "Î³",
          "Î´",
          "Îµ",
          "Î¶",
          "Î·",
          "Î¸",
          "Î¹",
          "Îº",
          "Î»",
          "Î¼",
          "Î½",
          "Î¾",
          "Ï€",
          "Ï",
          "Ïƒ",
          "Ï„",
          "Ï…",
          "Ï†",
          "Ï‡",
          "Ïˆ",
          "Ï‰",
        ],
        punctuation: [
          "Â¿",
          "Â¡",
          "â€½",
          "â€»",
          "â‘",
          "â‚",
          "â€¼",
          "â‡",
          "âˆ",
          "â‰",
          "â€¥",
          "â€¦",
          "Â·",
        ],
        typography: [
          "Â«",
          "Â»",
          "â€¹",
          "â€º",
          "â€",
          "â€Ÿ",
          "\u2018",
          "\u2019",
          "â€š",
          "â€›",
          "\u201C",
          "\u201D",
          "â€",
          "â€‘",
          "â€“",
          "â€”",
        ],
        phonetic: [
          "É‘",
          "É›",
          "Éª",
          "É’",
          "ÊŒ",
          "É™",
          "ÊŠ",
          "É”",
          "Ã¦",
          "Ã°",
          "Î¸",
          "Êƒ",
          "Ê’",
          "Å‹",
          "É¹",
          "É¾",
          "É½",
        ],
        dingbats: ["âœ‚", "âœ‰", "âœ", "âœ", "âœ‘", "âœ’", "âœ“", "âœ”", "âœ•", "âœ–", "âœ—", "âœ˜"],
        arrows: [
          "â¬†",
          "â¬‡",
          "â¬…",
          "â¡",
          "â†•",
          "â†”",
          "â†—",
          "â†˜",
          "â†™",
          "â†–",
          "â¤´",
          "â¤µ",
          "â†©",
          "â†ª",
        ],
        boxDrawing: [
          "â•”",
          "â•—",
          "â•š",
          "â•",
          "â• ",
          "â•£",
          "â•¦",
          "â•©",
          "â•¬",
          "â•‘",
          "â•",
          "â•’",
          "â•“",
          "â••",
          "â•–",
        ],
        blockElements: [
          "â–€",
          "â–„",
          "â–ˆ",
          "â–Œ",
          "â–",
          "â–‘",
          "â–’",
          "â–“",
          "â–",
          "â–•",
          "â––",
          "â–—",
          "â–˜",
          "â–™",
          "â–š",
          "â–›",
        ],
        astronomical: ["â˜€", "â˜½", "â˜¾", "â˜…", "â˜†", "â˜„", "âŠ™", "âŠ›", "âŠ•", "âŠ—"],
        currency: [
          "â‚¿",
          "â‚¹",
          "â‚©",
          "â‚½",
          "â‚¸",
          "â‚«",
          "â‚µ",
          "â‚¡",
          "â‚¢",
          "â‚£",
          "â‚¤",
          "â‚¥",
          "â‚¦",
          "â‚§",
          "â‚¨",
        ],
        chess: ["â™”", "â™•", "â™–", "â™—", "â™˜", "â™™", "â™š", "â™›", "â™œ", "â™", "â™", "â™Ÿ"],
        cards: [
          "â™ ",
          "â™£",
          "â™¥",
          "â™¦",
          "ğŸ‚¡",
          "ğŸ‚¢",
          "ğŸ‚£",
          "ğŸ‚¤",
          "ğŸ‚¥",
          "ğŸ‚¦",
          "ğŸ‚§",
          "ğŸ‚¨",
          "ğŸƒ",
        ],
        dice: ["âš€", "âš", "âš‚", "âšƒ", "âš„", "âš…"],
        zodiac: [
          "â™ˆ",
          "â™‰",
          "â™Š",
          "â™‹",
          "â™Œ",
          "â™",
          "â™",
          "â™",
          "â™",
          "â™‘",
          "â™’",
          "â™“",
        ],
        religious: ["âœ", "â˜ª", "âœ¡", "â˜¸", "â˜¯", "â˜¦", "â›©", "ğŸ•‰", "ğŸ›", "â¸¸"],
        hazard: ["â˜¢", "â˜£", "âš ", "âš¡", "â˜ ", "â›”", "ğŸš«", "âš ï¸"],
        recycling: ["â™²", "â™³", "â™´", "â™µ", "â™¶", "â™·", "â™¸", "â™¹", "â™º", "â™»"],
        gender: ["â™‚", "â™€", "âš¥", "âš§", "âš¤", "âš¢", "âš£"],
        weather: [
          "â˜€",
          "â˜",
          "â˜‚",
          "â˜ƒ",
          "â›…",
          "ğŸŒ¤",
          "ğŸŒ¥",
          "ğŸŒ¦",
          "ğŸŒ§",
          "â›ˆ",
          "ğŸŒ©",
          "ğŸŒª",
        ],
        communication: ["â˜", "âœ†", "âœ‰", "âœˆ", "ğŸ“±", "ğŸ’»", "ğŸ“§", "ğŸ“", "ğŸ“ ", "ğŸ“¡"],
        hands: [
          "â˜",
          "â˜›",
          "â˜œ",
          "â˜š",
          "ğŸ‘†",
          "ğŸ‘‡",
          "ğŸ‘ˆ",
          "ğŸ‘‰",
          "ğŸ¤™",
          "âœ‹",
          "ğŸ¤š",
          "ğŸ‘Œ",
          "âœŒ",
        ],
        smileys: ["â˜º", "â˜»", "â˜¹", "ã‹¡", "ãƒƒ", "ãƒ„", "ã€ ", "ê†œ"],
        crosses: ["âœš", "âœœ", "âœ", "âœ", "âœŸ", "â€ ", "â€¡", "â™±", "â™°", "â˜©"],
        stars: [
          "âœ¦",
          "âœ§",
          "âœ©",
          "âœª",
          "âœ«",
          "âœ¬",
          "âœ­",
          "âœ®",
          "âœ¯",
          "âœ°",
          "âœµ",
          "âœ¶",
          "âœ·",
          "âœ¸",
          "âœ¹",
        ],
        snowflakes: ["â„", "â…", "â†", "âœ»", "âœ¼", "âœ½", "âœ¾", "âŠ", "â‹"],
        hearts: [
          "â¤",
          "â¦",
          "â§",
          "â™¡",
          "â™¥",
          "ğŸ’”",
          "ğŸ’•",
          "ğŸ’–",
          "ğŸ’—",
          "ğŸ’˜",
          "ğŸ’",
          "ğŸ’",
          "ğŸ’Ÿ",
        ],
        flowers: [
          "âœ¿",
          "â€",
          "â",
          "âœ½",
          "âœ¾",
          "âƒ",
          "ğŸ’",
          "ğŸŒ¸",
          "ğŸŒ¹",
          "ğŸŒº",
          "ğŸŒ»",
          "ğŸŒ¼",
          "ğŸŒ·",
        ],
        japanese: [
          "ãŠ€",
          "ãŠ",
          "ãŠ‚",
          "ãŠƒ",
          "ãŠ„",
          "ãŠ…",
          "ãŠ†",
          "ãŠ‡",
          "ãŠˆ",
          "ãŠ‰",
          "ãŠŠ",
          "ãŠ‹",
          "ãŠŒ",
          "ãŠ",
        ],
        braille: [
          "â ",
          "â ƒ",
          "â ‡",
          "â ",
          "â Ÿ",
          "â ¿",
          "â¡¿",
          "â£¿",
          "â ‰",
          "â Š",
          "â ‹",
          "â Œ",
          "â ",
          "â ",
        ],
        dominos: ["ğŸ£", "ğŸ¤", "ğŸ¥", "ğŸ¦", "ğŸ§", "ğŸ¨", "ğŸ©", "ğŸª", "ğŸ«", "ğŸ¬"],
        planets: ["â˜¿", "â™€", "â™‚", "â™ƒ", "â™„", "â™…", "â™†", "âš³", "âš´", "âšµ", "âš¶", "âš·"],
        alchemical: [
          "ğŸœ",
          "ğŸœ‚",
          "ğŸœƒ",
          "ğŸœ„",
          "ğŸœ",
          "ğŸœ",
          "ğŸœ",
          "ğŸœ",
          "ğŸœ‘",
          "ğŸœ’",
          "ğŸœ“",
          "ğŸœ”",
        ],
        geometric: [
          "â—†",
          "â—‡",
          "â—‹",
          "â—",
          "â—",
          "â—‰",
          "â–¡",
          "â– ",
          "â–³",
          "â–½",
          "â–·",
          "â—",
          "â¬ ",
          "â¬¡",
          "â¬¢",
        ],
        ornamental: ["â–", "â§", "â¦", "â¡", "â", "â", "â›", "âœ", "âœ", "â•", "â–"],
        ballot: ["â˜", "â˜‘", "â˜’", "âœ“", "âœ”", "âœ•", "âœ–", "âœ—", "âœ˜", "â»"],
      };

      const chars = charSets[charType] || charSets.decorative;
      const separator = addSpacing ? " " : "";

      return workingText
        .split("")
        .map((c, i) => {
          if (c === " ") return c;
          if (i % 3 === 0) {
            return (
              chars[Math.floor(Math.random() * chars.length)] + separator + c
            );
          }
          return c;
        })
        .join("");
    }
    case "text-emoticons": {
      const mood = customSettings.mood || "happy";
      const addBefore = customSettings.addBefore !== false;

      const emoticons: Record<string, string[]> = {
        happy: ["â—•â€¿â—•", "(â— â€¿â— )", "ãƒ½(â—•ãƒ®â—•)ãƒ", "(âœ¿â— â€¿â— )", "â˜º", "à²¡â€¿à²¡", "(â—•á´—â—•âœ¿)"],
        sad: ["à²¥_à²¥", "(â•¥_â•¥)", "(T_T)", "( ; _ ; )", "(Â´;Ï‰;`)", "TT__TT"],
        angry: [
          "à² _à² ",
          "(â•¬à² ç›Šà² )",
          "(ãƒà² ç›Šà² )ãƒ",
          "ãƒ½(à² _à² )ãƒ",
          "(Â¬_Â¬)",
          "(-_-ãƒ¡)",
        ],
        cute: ["Ê•â€¢á´¥â€¢Ê”", "(=^ãƒ»^=)", "à¸…^â€¢ï»Œâ€¢^à¸…", "Ê• áµ”á´¥áµ” Ê”", "(â—•á´—â—•âœ¿)", "UwU"],
        shrug: ["Â¯\\_(ãƒ„)_/Â¯", "â”(Â´Ğ´`)â”Œ", "â•®(ï¸¶â–½ï¸¶)â•­", "ãƒ½(ã€‚_Â°)ãƒ"],
        love: [
          "â™¡(á¢ á´— á¢)â™¡",
          "(â™¥Ï‰â™¥*)",
          "(*â™¡âˆ€â™¡)",
          "(â—â€¢á´—â€¢â—)â¤",
          "(ç¬â™¥Ï‰â™¥ç¬)",
          "( Ë˜ Â³Ë˜)â™¥",
        ],
        excited: [
          "ãƒ½(>âˆ€<)ï¾‰",
          "\\(â˜…Ï‰â˜…)/",
          "ãƒ½(â˜…Ï‰â˜…)ãƒ",
          "(ï¾‰â‰§âˆ€â‰¦)ï¾‰",
          "Ù©(â—•â€¿â—•)Û¶",
          "\\(^o^)/",
        ],
        sleepy: [
          "(Â´-Ï‰-`)",
          "(âˆª.âˆª )...zzz",
          "(-Ï‰-) zzZ",
          "(ï¿£oï¿£) zzZZ",
          "(Â´ï½`)",
        ],
        confused: [
          "(?_?)",
          "(ãƒ»_ãƒ»?)",
          "(âŠ™_âŠ™)?",
          "(â—_â—;)",
          "(=_=)",
          "(Â´-Ï‰-`)?",
        ],
        cool: ["(âŒâ– _â– )", "(â€¢_â€¢) ( â€¢_â€¢)>âŒâ– -â– ", "B-)", "(â–€Ì¿Ä¹Ì¯â–€Ì¿ Ì¿)", "á•™(â–€Ì¿ÄºÌ¯â–€Ì¿ Ì¿)á•—"],
        crying: [
          "(á—’á—£á—•)Õ",
          "(ã£Ë˜Ì©â•­â•®Ë˜Ì©)ã£",
          "(;Â´à¼àº¶Ğ”à¼àº¶`)",
          "(ãƒĞ”`)ãƒ»ã‚œãƒ»ã€‚",
          "(;Ï‰;)",
        ],
        laughing: ["(â‰§â–½â‰¦)", "á••( á› )á•—", "(^â–½^)", "(á—’á—¨á—•)", "(â‰§â—¡â‰¦)", "â”(ã‚šâˆ€ã‚š)â”"],
        winking: ["(^_~)", "(^_-)", "( Ì„â–½ Ì„)", "(Â¬â€¿Â¬)", "(~_^)"],
        surprised: ["Î£(Â°â–³Â°)", "(âŠ™_âŠ™)", "Î£(ï¾ŸĞ”ï¾Ÿ)", "( ê’ªĞ”ê’ª)ãƒ", "(Â°ãƒ­Â°) !"],
        nervous: ["(Â°â–½Â°;)", "(ï¼›ä¸€_ä¸€)", "(âŠ™ï¹âŠ™)", "(ã‚œ-ã‚œ)", "(ãƒ¼ãƒ¼;)"],
        disappointed: ["(â—â€¸â—Ÿ)", "(._.)", "(ï¼›âŒ£Ì€_âŒ£Ì)", "(Â´-Îµ-`)", "(-_-;)ãƒ»ãƒ»ãƒ»"],
        scared: [
          "Î£(ï¾ŸĞ´ï¾Ÿ)",
          "(((( ;Â°Ğ”Â°))))",
          "(ê¿ï¹ê¿;)",
          "(Â°â–³Â°|||)",
          "!!!(âŠƒĞ”)âŠƒ",
        ],
        evil: ["(Ïˆ`âˆ‡Â´)Ïˆ", "(â–¼âˆ€â–¼)", "Ïˆ(ï½€âˆ‡Â´)Ïˆ", "( â—‰â— â—‰)", "(ê¦Â°á·„Ğ´Â°á·…)"],
        cat: [
          "(=^ãƒ»Ï‰ãƒ»^=)",
          "(=^â€¥^=)",
          "(=^â—¡^=)",
          "á“šá˜á—¢",
          "à¸…(^â€¢ï»Œâ€¢^à¸…)",
          "(ê†¤.ê†¤)",
        ],
        dog: ["âˆªãƒ»á´¥ãƒ»âˆª", "(áµ”á´¥áµ”)", "â–¼ãƒ»á´¥ãƒ»â–¼", "U Â´á´¥` U", "(â—•á´¥â—•Ê‹)"],
        bear: ["Ê• â€¢á´¥â€¢ Ê”", "Ê•Â·á´¥Â·Ê”", "Ê• áµ”á´¥áµ” Ê”", "Ê• â‰§á´¥â‰¦ Ê”", "Ê•â™¥á´¥â™¥Ê”"],
        bunny: ["(\\ /) ( . .) ( >ğŸ¥•", "(\\(\\  (=':'=) (\\'')_(''))", "á¡•á µá Šá¡ƒ"],
        spider: ["/â•²/( â€¢Ì€ Ï‰ â€¢Ì )\\â•±\\"],
        fish: ["><(((Â°>", "<Â°)))><", "á›¦><((((Â°á›¦>"],
        wizard: ["(âˆ©`-Â´)âŠƒâ”â˜†ï¾Ÿ.*", "(âˆ© Í¡Â° ÍœÊ– Í¡Â°)âŠƒâ”â˜†ï¾Ÿ.*", "âŠ‚( ãƒ» Ì«ãƒ»)âŠƒâ”â˜†ï¾Ÿ.*"],
        warrior: ["â•°(â–”âˆ€â–”)â•¯", "á•¦(Ã²_Ã³Ë‡)á•¤", "(à¸‡ â€¢Ì€_â€¢Ì)à¸‡"],
        king: ["â™›(á´—â€¿á´—)â™›", "â™”(Ë˜â€¿Ë˜)â™”"],
        music: ["â™ªâ™«â€¢*Â¨*â€¢â™«â™ª", "â™ª(Â´Îµ` )", "â™«â™ªâ™¬"],
        dance: ["â™ª(^âˆ‡^*)", "â™ª(ãƒ»Ï‰ãƒ»)ãƒ", "â”Œ(â˜…oâ˜†)â”˜â™ª"],
        flex: ["á•¦(Ã²_Ã³Ë‡)á•¤", "á•™(â‡€â€¸â†¼â€¶)á•—", "á•™(â–€Ì¿ÄºÌ¯â–€Ì¿ Ì¿)á•—"],
        disapproval: ["à² â•­â•®à² ", "à² _à² ", "(à² _à² )"],
        blushing: ["(â„ â„>â„ â–½ â„<â„ â„)", "(*ï¾‰Ï‰ï¾‰)", "(â„â„â„ â„ â„â„â„)"],
        sparkles: ["(ï¾‰â—•ãƒ®â—•)ï¾‰*:Â·ï¾Ÿâœ§", "ï¾Ÿ+.ï¾Ÿ(Â´â–½`äºº)ï¾Ÿ+.ï¾Ÿ"],
        hugging: ["(ã¤â‰§â–½â‰¦)ã¤", "(âŠƒ â€¢ Ê–Ì« â€¢ )âŠƒ", "(âŠƒï½¡â€¢Ìâ€¿â€¢Ì€ï½¡)âŠƒ"],
        tableFlip: ["(â•¯Â°â–¡Â°)â•¯ï¸µ â”»â”â”»", "(ãƒà² ç›Šà² )ãƒå½¡â”»â”â”»", "(ï¾‰â‰§âˆ‡â‰¦)ï¾‰ ï¾ â”»â”â”»"],
        putBack: ["â”¬â”€â”¬ãƒ( Âº _ Âºãƒ)", "â”¬â”€â”€â”¬â—¡ï¾‰(Â° -Â°ï¾‰)"],
        running: ["Îµ=Îµ=Îµ=â”Œ(;*Â´Ğ”`)ï¾‰", "Îµ=Îµ=Îµ=(ï¾‰â‰§âˆ‡â‰¦)ï¾‰"],
        shooting: ["(â•­â˜ Í¡Â° ÍœÊ– Í¡Â° )â•­â˜", "(â˜ï¾Ÿâˆ€ï¾Ÿ)â˜", "â˜(âŒâ– _â– )â˜"],
        peek: ["â”¬â”´â”¬â”´â”¤ ÍœÊ– Í¡Â°) â”œâ”¬â”´â”¬â”´", "â”¬â”´â”¬â”´â”¤(ãƒ»_â”œâ”¬â”´â”¬â”´"],
        zombie: ["[Â¬Âº-Â°]Â¬", "Îµ/ÌµÍ‡Ì¿Ì¿/'Ì¿'Ì¿ Ì¿(â—¡ï¸µâ—¡)"],
        robot: ["{â€¢Ìƒ_â€¢Ìƒ}", "[â€¢Ì€á´—â€¢Ì]Ùˆ", "âŸ¨â€¢_â€¢âŸ©"],
        alien: ["ê‰º_ê‰º", "âŠ›à¤ ÌƒâŠà¤ ÌƒâŠ›", "(â—£_â—¢)"],
        ghost: ["âŠ‚(â—‰â€¿â—‰)ã¤", "(âŠƒ â—‰ â€¿ â—‰ )âŠƒ", "Îµ(Â´×¡Ö¼ï¸µ×¡Ö¼`)Ğ·"],
        pirate: ["â˜ á••( á› )á•—â˜ ", "âš“á••( á› )á•—âš“"],
        ninja: ["(âŒ’_âŒ’;)", "(Â¬â€¿Â¬)", "á••( á› )á•—"],
        pensive: ["(._. )", "(._.)", "(Â´._.`)"],
        content: ["(â—¡â€¿â—¡âœ¿)", "(â— â€¿â— âœ¿)", "(â—•â€¿â—•âœ¿)"],
        determined: ["(à¸‡'Ì€-'Ì)à¸‡", "(à¸‡ â€¢Ì€_â€¢Ì)à¸‡", "á•¦(Ã²_Ã³Ë‡)á•¤"],
        suspicious: ["(Â¬â€¿Â¬)", "(Â¬_Â¬)", "(Í¡ Â° ÍœÊ– Í¡ Â°)"],
        celebration: ["â˜†*:.ï½¡.o(â‰§â–½â‰¦)o.ï½¡.:*â˜†", "âœ²ï¾Ÿ*ï½¡âœ§Ù©(ãƒ»Ï‰ãƒ»)Ùˆâœ§ï½¡*ï¾Ÿâœ²"],
      };

      const emoticonList = emoticons[mood] || emoticons.happy;
      const emote =
        emoticonList[Math.floor(Math.random() * emoticonList.length)];

      if (addBefore) {
        return emote + " " + workingText;
      } else {
        return workingText + " " + emote;
      }
    }
    case "lenny-face": {
      const lennyStyle = customSettings.lennyStyle || "classic";
      const position = customSettings.position || "after";

      const lennies: Record<string, string> = {
        classic: "( Í¡Â° ÍœÊ– Í¡Â°)",
        surprised: "( Í¡áµ” ÍœÊ– Í¡áµ”)",
        wink: "( Í¡~ ÍœÊ– Í¡Â°)",
        flipped: "( Íœã€‚ Í¡Ê– Íœã€‚)",
        bear: "Ê• Í¡Â° ÍœÊ– Í¡Â°Ê”",
        strong: "á•¦( Í¡Â° ÍœÊ– Í¡Â°)á•¤",
        sparkle: "( Í¡Â° ÍœÊ– Í¡Â°)âœ§",
        fight: "(à¸‡ Í¡Â° ÍœÊ– Í¡Â°)à¸‡",
        mustache: "( Í¡Â° ÍœÊ– Í¡Â°)ï¾‰âŒâ– -â– ",
        sad: "( Í¡Â° Ê–Ì¯ Í¡Â°)",
        angry: "( Í Â° ÍŸÊ– Í¡Â°)",
        disapproval: "à² _à² ",
        dealWithIt: "(âŒâ– _â– )",
        suspicious: "( Í¡Ê˜ ÍœÊ– Í¡Ê˜)",
        tableLenny: "â”¬â”´â”¬â”´â”¤ Í¡Â° ÍœÊ– Í¡Â°)â”œâ”¬â”´â”¬â”´",
        spider: "/â•²/( Í¡Â° Í¡Â° ÍœÊ– Í¡Â° Í¡Â°)/\\â•±\\",
        donger: "ãƒ½à¼¼ Í¡Â° ÍœÊ– Í¡Â° à¼½ï¾‰",
        magic: "(â˜ Í¡Â° ÍœÊ– Í¡Â°)â˜",
        double: "Í¡Â° ÍœÊ– Í¡ â€“",
        wizard: "(âˆ© Í¡Â° ÍœÊ– Í¡Â°)âŠƒâ”â˜†ï¾Ÿ",
        running: "Îµ=Îµ=( Í¡Â° ÍœÊ– Í¡Â°)",
        heart: "( Í¡Â° ÍœÊ– Í¡Â°)ï¾‰â™¡",
        musicLenny: "â™ª( Í¡Â° ÍœÊ– Í¡Â°)â™ª",
        gun: "â•¾â”â•¤ãƒ‡â•¦ï¸»( Í¡Â° ÍœÊ– Í¡Â°)",
        wave: "~( Í¡Â° ÍœÊ– Í¡Â°)~",
        shrug: "Â¯\\( Í¡Â° ÍœÊ– Í¡Â°)/Â¯",
        uwu: "( Í¡UwU)",
        owo: "( Í¡OwO)",
        sniper: "â–„ï¸»Ì·Ì¿â”»Ì¿â•â”ä¸€( Í¡Â° ÍœÊ– Í¡Â°)",
        angel: "â˜œ( Í¡Â° ÍœÊ– Í¡Â°â˜œ)",
        devil: "Ïˆ( Í¡Â° ÍœÊ– Í¡Â°)Ïˆ",
        sword: "(à¸‡ Í¡Â° ÍœÊ– Í¡Â°)à¸‡âš”",
        crown: "â™›( Í¡Â° ÍœÊ– Í¡Â°)â™›",
        starsLenny: "â˜…( Í¡Â° ÍœÊ– Í¡Â°)â˜…",
        cool: "( Í¡Â° ÍœÊ– Í¡Â°)>âŒâ– -â– ",
        flex: "á•™( Í¡Â° ÍœÊ– Í¡Â°)á•—",
        ghostLenny: "( Í¡Â° ÍœÊ– Í¡Â°)âŠƒâ”â˜†ï¾Ÿ.*",
        faceSwap: "( Â° Íœ Ê– Â°)",
        tiny: "( Í¡Â°á´¥ Í¡Â°)",
        confusedLenny: "( Â° ÍœÊ– Â°)",
        evilNest: "( Í¡Â°( Í¡Â° ÍœÊ–( Í¡Â° ÍœÊ– Í¡Â°)Ê– Í¡Â°) Í¡Â°)",
        pointing: "â˜( Í¡Â° ÍœÊ– Í¡Â°)â˜",
        hug: "âŠ‚( Í¡Â° ÍœÊ– Í¡Â°)âŠƒ",
        doubleEyes: "( Í¡â—‰ ÍœÊ– Í¡â—‰)",
        mega: "( Í¡âŠ™ ÍœÊ– Í¡âŠ™)",
        cryLenny: "( Í¡à²¥ ÍœÊ– Í¡à²¥)",
        derp: "( Í¡ Í¡Â° Íœ Ê– Í¡ Í¡Â°)",
        concerned: "( Í¡Â° Ê–Ì¯ Í¡Â°)",
        blank: "( Í¡ ÍœÊ– Í¡ )",
        money: "[Ì²Ì…$Ì²Ì…(Ì²Ì… Í¡Â° ÍœÊ– Í¡Â°Ì²Ì…)Ì²Ì…$Ì²Ì…]",
      };

      const lenny = lennies[lennyStyle] || lennies.classic;

      switch (position) {
        case "before":
          return lenny + " " + workingText;
        case "after":
          return workingText + " " + lenny;
        case "both":
          return lenny + " " + workingText + " " + lenny;
        case "eachWord":
          return workingText
            .split(" ")
            .map((word) => word + " " + lenny)
            .join(" ");
        default:
          return workingText + " " + lenny;
      }
    }
    case "hex-code":
      return workingText
        .split("")
        .map((char) => char.charCodeAt(0).toString(16).padStart(2, "0"))
        .join(" ");

    case "base64":
      try {
        return btoa(workingText);
      } catch (e) {
        return "Encoding Error: Use valid text characters.";
      }

    case "reverse-text":
      return workingText.split("").reverse().join("");

    case "caesar-cipher": {
      const shift = Number(customSettings.shift) || 3;
      return workingText
        .split("")
        .map((char) => {
          if (char.match(/[a-z]/i)) {
            const code = char.charCodeAt(0);
            const base = code >= 65 && code <= 90 ? 65 : 97;
            return String.fromCharCode(((code - base + shift) % 26) + base);
          }
          return char;
        })
        .join("");
    }

    case "rot13": {
      return workingText
        .split("")
        .map((char) => {
          if (char.match(/[a-z]/i)) {
            const code = char.charCodeAt(0);
            const base = code >= 65 && code <= 90 ? 65 : 97;
            return String.fromCharCode(((code - base + 13) % 26) + base);
          }
          return char;
        })
        .join("");
    }

    default:
      return workingText;
  }
}
